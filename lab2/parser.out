Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> m_expr
Rule 1     m_expr -> expression
Rule 2     m_expr -> expression m_expr
Rule 3     expression -> c_block
Rule 4     expression -> base_expr
Rule 5     expression -> base_expr ;
Rule 6     expression -> if_st
Rule 7     expression -> loop_st
Rule 8     base_expr -> assignment
Rule 9     base_expr -> return
Rule 10    base_expr -> print
Rule 11    operation -> number
Rule 12    operation -> unary_operation
Rule 13    operation -> function
Rule 14    c_block -> { m_expr }
Rule 15    print -> PRINT print_b
Rule 16    print_b -> STRING
Rule 17    print_b -> operation
Rule 18    print_b -> print_b , operation
Rule 19    return -> RETURN condition
Rule 20    return -> RETURN operation
Rule 21    return -> RETURN
Rule 22    array -> [ array_b ]
Rule 23    array_b -> number
Rule 24    array_b -> array_b , number
Rule 25    array_b -> eps
Rule 26    matrix -> [ matrix_b ]
Rule 27    matrix_b -> array
Rule 28    matrix_b -> matrix_b , array
Rule 29    matrix_b -> eps
Rule 30    number -> INTNUM
Rule 31    number -> FLOATNUM
Rule 32    number -> ID
Rule 33    range -> ID [ int_variable , int_variable ]
Rule 34    int_variable -> INTNUM
Rule 35    int_variable -> ID
Rule 36    function -> function_n ( number )
Rule 37    function_n -> ONES
Rule 38    function_n -> EYE
Rule 39    function_n -> ZEROS
Rule 40    condition -> compare
Rule 41    loop_st -> while
Rule 42    loop_st -> for
Rule 43    while -> WHILE ( condition ) loop_b
Rule 44    for -> FOR ID = int_variable : int_variable loop_b
Rule 45    loop_b -> loop_expr
Rule 46    loop_b -> loop_expr ;
Rule 47    loop_b -> { m_loop_expr }
Rule 48    loop_expr -> base_expr
Rule 49    loop_expr -> loop_st
Rule 50    loop_expr -> if_loop_st
Rule 51    loop_expr -> BREAK
Rule 52    loop_expr -> CONTINUE
Rule 53    m_loop_expr -> m_loop_expr loop_b
Rule 54    m_loop_expr -> loop_b
Rule 55    if_st -> IF ( condition ) expression else_st
Rule 56    else_st -> ELSE expression
Rule 57    else_st -> eps
Rule 58    if_loop_st -> IF ( condition ) loop_b else_loop_st
Rule 59    else_loop_st -> ELSE loop_b
Rule 60    else_loop_st -> eps
Rule 61    eps -> <empty>
Rule 62    assign_expr -> ID
Rule 63    assign_expr -> range
Rule 64    assignment -> assign_expr = matrix
Rule 65    assignment -> assign_expr = STRING
Rule 66    assignment -> assign_expr = operation
Rule 67    assignment -> assign_expr ASSIGNADD operation
Rule 68    assignment -> assign_expr ASSIGNSUB operation
Rule 69    assignment -> assign_expr ASSIGNMUL operation
Rule 70    assignment -> assign_expr ASSIGNDIV operation
Rule 71    unary_operation -> negation
Rule 72    unary_operation -> transpose
Rule 73    negation -> - number
Rule 74    transpose -> ID '
Rule 75    operation -> operation + operation
Rule 76    operation -> operation - operation
Rule 77    operation -> operation DOTADD operation
Rule 78    operation -> operation DOTSUB operation
Rule 79    operation -> operation * operation
Rule 80    operation -> operation / operation
Rule 81    operation -> operation DOTMUL operation
Rule 82    operation -> operation DOTDIV operation
Rule 83    operation -> ( operation )
Rule 84    compare -> operation < operation
Rule 85    compare -> operation > operation
Rule 86    compare -> operation EQ operation
Rule 87    compare -> operation NEQ operation
Rule 88    compare -> operation GEQ operation
Rule 89    compare -> operation LEQ operation

Terminals, with rules where they appear

'                    : 74
(                    : 36 43 55 58 83
)                    : 36 43 55 58 83
*                    : 79
+                    : 75
,                    : 18 24 28 33
-                    : 73 76
/                    : 80
:                    : 44
;                    : 5 46
<                    : 84
=                    : 44 64 65 66
>                    : 85
ASSIGNADD            : 67
ASSIGNDIV            : 70
ASSIGNMUL            : 69
ASSIGNSUB            : 68
BREAK                : 51
CONTINUE             : 52
DOTADD               : 77
DOTDIV               : 82
DOTMUL               : 81
DOTSUB               : 78
ELSE                 : 56 59
EQ                   : 86
EYE                  : 38
FLOATNUM             : 31
FOR                  : 44
GEQ                  : 88
ID                   : 32 33 35 44 62 74
IF                   : 55 58
INTNUM               : 30 34
LEQ                  : 89
NEQ                  : 87
ONES                 : 37
PRINT                : 15
RETURN               : 19 20 21
STRING               : 16 65
WHILE                : 43
ZEROS                : 39
[                    : 22 26 33
]                    : 22 26 33
error                : 
{                    : 14 47
}                    : 14 47

Nonterminals, with rules where they appear

array                : 27 28
array_b              : 22 24
assign_expr          : 64 65 66 67 68 69 70
assignment           : 8
base_expr            : 4 5 48
c_block              : 3
compare              : 40
condition            : 19 43 55 58
else_loop_st         : 58
else_st              : 55
eps                  : 25 29 57 60
expression           : 1 2 55 56
for                  : 42
function             : 13
function_n           : 36
if_loop_st           : 50
if_st                : 6
int_variable         : 33 33 44 44
loop_b               : 43 44 53 54 58 59
loop_expr            : 45 46
loop_st              : 7 49
m_expr               : 2 14 0
m_loop_expr          : 47 53
matrix               : 64
matrix_b             : 26 28
negation             : 71
number               : 11 23 24 36 73
operation            : 17 18 20 66 67 68 69 70 75 75 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 84 84 85 85 86 86 87 87 88 88 89 89
print                : 10
print_b              : 15 18
range                : 63
return               : 9
transpose            : 72
unary_operation      : 12
while                : 41

Parsing method: LALR

state 0

    (0) S' -> . m_expr
    (1) m_expr -> . expression
    (2) m_expr -> . expression m_expr
    (3) expression -> . c_block
    (4) expression -> . base_expr
    (5) expression -> . base_expr ;
    (6) expression -> . if_st
    (7) expression -> . loop_st
    (14) c_block -> . { m_expr }
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (55) if_st -> . IF ( condition ) expression else_st
    (41) loop_st -> . while
    (42) loop_st -> . for
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    {               shift and go to state 7
    IF              shift and go to state 11
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    m_expr                         shift and go to state 1
    expression                     shift and go to state 2
    c_block                        shift and go to state 3
    base_expr                      shift and go to state 4
    if_st                          shift and go to state 5
    loop_st                        shift and go to state 6
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 1

    (0) S' -> m_expr .



state 2

    (1) m_expr -> expression .
    (2) m_expr -> expression . m_expr
    (1) m_expr -> . expression
    (2) m_expr -> . expression m_expr
    (3) expression -> . c_block
    (4) expression -> . base_expr
    (5) expression -> . base_expr ;
    (6) expression -> . if_st
    (7) expression -> . loop_st
    (14) c_block -> . { m_expr }
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (55) if_st -> . IF ( condition ) expression else_st
    (41) loop_st -> . while
    (42) loop_st -> . for
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    $end            reduce using rule 1 (m_expr -> expression .)
    }               reduce using rule 1 (m_expr -> expression .)
    {               shift and go to state 7
    IF              shift and go to state 11
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    expression                     shift and go to state 2
    m_expr                         shift and go to state 21
    c_block                        shift and go to state 3
    base_expr                      shift and go to state 4
    if_st                          shift and go to state 5
    loop_st                        shift and go to state 6
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 3

    (3) expression -> c_block .

    {               reduce using rule 3 (expression -> c_block .)
    IF              reduce using rule 3 (expression -> c_block .)
    RETURN          reduce using rule 3 (expression -> c_block .)
    PRINT           reduce using rule 3 (expression -> c_block .)
    WHILE           reduce using rule 3 (expression -> c_block .)
    FOR             reduce using rule 3 (expression -> c_block .)
    ID              reduce using rule 3 (expression -> c_block .)
    $end            reduce using rule 3 (expression -> c_block .)
    }               reduce using rule 3 (expression -> c_block .)
    ELSE            reduce using rule 3 (expression -> c_block .)


state 4

    (4) expression -> base_expr .
    (5) expression -> base_expr . ;

    {               reduce using rule 4 (expression -> base_expr .)
    IF              reduce using rule 4 (expression -> base_expr .)
    RETURN          reduce using rule 4 (expression -> base_expr .)
    PRINT           reduce using rule 4 (expression -> base_expr .)
    WHILE           reduce using rule 4 (expression -> base_expr .)
    FOR             reduce using rule 4 (expression -> base_expr .)
    ID              reduce using rule 4 (expression -> base_expr .)
    $end            reduce using rule 4 (expression -> base_expr .)
    }               reduce using rule 4 (expression -> base_expr .)
    ELSE            reduce using rule 4 (expression -> base_expr .)
    ;               shift and go to state 22


state 5

    (6) expression -> if_st .

    {               reduce using rule 6 (expression -> if_st .)
    IF              reduce using rule 6 (expression -> if_st .)
    RETURN          reduce using rule 6 (expression -> if_st .)
    PRINT           reduce using rule 6 (expression -> if_st .)
    WHILE           reduce using rule 6 (expression -> if_st .)
    FOR             reduce using rule 6 (expression -> if_st .)
    ID              reduce using rule 6 (expression -> if_st .)
    $end            reduce using rule 6 (expression -> if_st .)
    }               reduce using rule 6 (expression -> if_st .)
    ELSE            reduce using rule 6 (expression -> if_st .)


state 6

    (7) expression -> loop_st .

    {               reduce using rule 7 (expression -> loop_st .)
    IF              reduce using rule 7 (expression -> loop_st .)
    RETURN          reduce using rule 7 (expression -> loop_st .)
    PRINT           reduce using rule 7 (expression -> loop_st .)
    WHILE           reduce using rule 7 (expression -> loop_st .)
    FOR             reduce using rule 7 (expression -> loop_st .)
    ID              reduce using rule 7 (expression -> loop_st .)
    $end            reduce using rule 7 (expression -> loop_st .)
    }               reduce using rule 7 (expression -> loop_st .)
    ELSE            reduce using rule 7 (expression -> loop_st .)


state 7

    (14) c_block -> { . m_expr }
    (1) m_expr -> . expression
    (2) m_expr -> . expression m_expr
    (3) expression -> . c_block
    (4) expression -> . base_expr
    (5) expression -> . base_expr ;
    (6) expression -> . if_st
    (7) expression -> . loop_st
    (14) c_block -> . { m_expr }
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (55) if_st -> . IF ( condition ) expression else_st
    (41) loop_st -> . while
    (42) loop_st -> . for
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    {               shift and go to state 7
    IF              shift and go to state 11
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    m_expr                         shift and go to state 23
    expression                     shift and go to state 2
    c_block                        shift and go to state 3
    base_expr                      shift and go to state 4
    if_st                          shift and go to state 5
    loop_st                        shift and go to state 6
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 8

    (8) base_expr -> assignment .

    ;               reduce using rule 8 (base_expr -> assignment .)
    {               reduce using rule 8 (base_expr -> assignment .)
    IF              reduce using rule 8 (base_expr -> assignment .)
    RETURN          reduce using rule 8 (base_expr -> assignment .)
    PRINT           reduce using rule 8 (base_expr -> assignment .)
    WHILE           reduce using rule 8 (base_expr -> assignment .)
    FOR             reduce using rule 8 (base_expr -> assignment .)
    ID              reduce using rule 8 (base_expr -> assignment .)
    $end            reduce using rule 8 (base_expr -> assignment .)
    }               reduce using rule 8 (base_expr -> assignment .)
    ELSE            reduce using rule 8 (base_expr -> assignment .)
    BREAK           reduce using rule 8 (base_expr -> assignment .)
    CONTINUE        reduce using rule 8 (base_expr -> assignment .)


state 9

    (9) base_expr -> return .

    ;               reduce using rule 9 (base_expr -> return .)
    {               reduce using rule 9 (base_expr -> return .)
    IF              reduce using rule 9 (base_expr -> return .)
    RETURN          reduce using rule 9 (base_expr -> return .)
    PRINT           reduce using rule 9 (base_expr -> return .)
    WHILE           reduce using rule 9 (base_expr -> return .)
    FOR             reduce using rule 9 (base_expr -> return .)
    ID              reduce using rule 9 (base_expr -> return .)
    $end            reduce using rule 9 (base_expr -> return .)
    }               reduce using rule 9 (base_expr -> return .)
    ELSE            reduce using rule 9 (base_expr -> return .)
    BREAK           reduce using rule 9 (base_expr -> return .)
    CONTINUE        reduce using rule 9 (base_expr -> return .)


state 10

    (10) base_expr -> print .

    ;               reduce using rule 10 (base_expr -> print .)
    {               reduce using rule 10 (base_expr -> print .)
    IF              reduce using rule 10 (base_expr -> print .)
    RETURN          reduce using rule 10 (base_expr -> print .)
    PRINT           reduce using rule 10 (base_expr -> print .)
    WHILE           reduce using rule 10 (base_expr -> print .)
    FOR             reduce using rule 10 (base_expr -> print .)
    ID              reduce using rule 10 (base_expr -> print .)
    $end            reduce using rule 10 (base_expr -> print .)
    }               reduce using rule 10 (base_expr -> print .)
    ELSE            reduce using rule 10 (base_expr -> print .)
    BREAK           reduce using rule 10 (base_expr -> print .)
    CONTINUE        reduce using rule 10 (base_expr -> print .)


state 11

    (55) if_st -> IF . ( condition ) expression else_st

    (               shift and go to state 24


state 12

    (41) loop_st -> while .

    {               reduce using rule 41 (loop_st -> while .)
    IF              reduce using rule 41 (loop_st -> while .)
    RETURN          reduce using rule 41 (loop_st -> while .)
    PRINT           reduce using rule 41 (loop_st -> while .)
    WHILE           reduce using rule 41 (loop_st -> while .)
    FOR             reduce using rule 41 (loop_st -> while .)
    ID              reduce using rule 41 (loop_st -> while .)
    $end            reduce using rule 41 (loop_st -> while .)
    }               reduce using rule 41 (loop_st -> while .)
    ELSE            reduce using rule 41 (loop_st -> while .)
    ;               reduce using rule 41 (loop_st -> while .)
    BREAK           reduce using rule 41 (loop_st -> while .)
    CONTINUE        reduce using rule 41 (loop_st -> while .)


state 13

    (42) loop_st -> for .

    {               reduce using rule 42 (loop_st -> for .)
    IF              reduce using rule 42 (loop_st -> for .)
    RETURN          reduce using rule 42 (loop_st -> for .)
    PRINT           reduce using rule 42 (loop_st -> for .)
    WHILE           reduce using rule 42 (loop_st -> for .)
    FOR             reduce using rule 42 (loop_st -> for .)
    ID              reduce using rule 42 (loop_st -> for .)
    $end            reduce using rule 42 (loop_st -> for .)
    }               reduce using rule 42 (loop_st -> for .)
    ELSE            reduce using rule 42 (loop_st -> for .)
    ;               reduce using rule 42 (loop_st -> for .)
    BREAK           reduce using rule 42 (loop_st -> for .)
    CONTINUE        reduce using rule 42 (loop_st -> for .)


state 14

    (64) assignment -> assign_expr . = matrix
    (65) assignment -> assign_expr . = STRING
    (66) assignment -> assign_expr . = operation
    (67) assignment -> assign_expr . ASSIGNADD operation
    (68) assignment -> assign_expr . ASSIGNSUB operation
    (69) assignment -> assign_expr . ASSIGNMUL operation
    (70) assignment -> assign_expr . ASSIGNDIV operation

    =               shift and go to state 25
    ASSIGNADD       shift and go to state 26
    ASSIGNSUB       shift and go to state 27
    ASSIGNMUL       shift and go to state 28
    ASSIGNDIV       shift and go to state 29


state 15

    (19) return -> RETURN . condition
    (20) return -> RETURN . operation
    (21) return -> RETURN .
    (40) condition -> . compare
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (84) compare -> . operation < operation
    (85) compare -> . operation > operation
    (86) compare -> . operation EQ operation
    (87) compare -> . operation NEQ operation
    (88) compare -> . operation GEQ operation
    (89) compare -> . operation LEQ operation
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

  ! shift/reduce conflict for ID resolved as shift
    ;               reduce using rule 21 (return -> RETURN .)
    {               reduce using rule 21 (return -> RETURN .)
    IF              reduce using rule 21 (return -> RETURN .)
    RETURN          reduce using rule 21 (return -> RETURN .)
    PRINT           reduce using rule 21 (return -> RETURN .)
    WHILE           reduce using rule 21 (return -> RETURN .)
    FOR             reduce using rule 21 (return -> RETURN .)
    $end            reduce using rule 21 (return -> RETURN .)
    }               reduce using rule 21 (return -> RETURN .)
    ELSE            reduce using rule 21 (return -> RETURN .)
    BREAK           reduce using rule 21 (return -> RETURN .)
    CONTINUE        reduce using rule 21 (return -> RETURN .)
    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

  ! ID              [ reduce using rule 21 (return -> RETURN .) ]

    condition                      shift and go to state 30
    operation                      shift and go to state 31
    compare                        shift and go to state 32
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 16

    (15) print -> PRINT . print_b
    (16) print_b -> . STRING
    (17) print_b -> . operation
    (18) print_b -> . print_b , operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    STRING          shift and go to state 48
    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    print_b                        shift and go to state 47
    operation                      shift and go to state 49
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 17

    (43) while -> WHILE . ( condition ) loop_b

    (               shift and go to state 50


state 18

    (44) for -> FOR . ID = int_variable : int_variable loop_b

    ID              shift and go to state 51


state 19

    (62) assign_expr -> ID .
    (33) range -> ID . [ int_variable , int_variable ]

    =               reduce using rule 62 (assign_expr -> ID .)
    ASSIGNADD       reduce using rule 62 (assign_expr -> ID .)
    ASSIGNSUB       reduce using rule 62 (assign_expr -> ID .)
    ASSIGNMUL       reduce using rule 62 (assign_expr -> ID .)
    ASSIGNDIV       reduce using rule 62 (assign_expr -> ID .)
    [               shift and go to state 52


state 20

    (63) assign_expr -> range .

    =               reduce using rule 63 (assign_expr -> range .)
    ASSIGNADD       reduce using rule 63 (assign_expr -> range .)
    ASSIGNSUB       reduce using rule 63 (assign_expr -> range .)
    ASSIGNMUL       reduce using rule 63 (assign_expr -> range .)
    ASSIGNDIV       reduce using rule 63 (assign_expr -> range .)


state 21

    (2) m_expr -> expression m_expr .

    $end            reduce using rule 2 (m_expr -> expression m_expr .)
    }               reduce using rule 2 (m_expr -> expression m_expr .)


state 22

    (5) expression -> base_expr ; .

    {               reduce using rule 5 (expression -> base_expr ; .)
    IF              reduce using rule 5 (expression -> base_expr ; .)
    RETURN          reduce using rule 5 (expression -> base_expr ; .)
    PRINT           reduce using rule 5 (expression -> base_expr ; .)
    WHILE           reduce using rule 5 (expression -> base_expr ; .)
    FOR             reduce using rule 5 (expression -> base_expr ; .)
    ID              reduce using rule 5 (expression -> base_expr ; .)
    $end            reduce using rule 5 (expression -> base_expr ; .)
    }               reduce using rule 5 (expression -> base_expr ; .)
    ELSE            reduce using rule 5 (expression -> base_expr ; .)


state 23

    (14) c_block -> { m_expr . }

    }               shift and go to state 53


state 24

    (55) if_st -> IF ( . condition ) expression else_st
    (40) condition -> . compare
    (84) compare -> . operation < operation
    (85) compare -> . operation > operation
    (86) compare -> . operation EQ operation
    (87) compare -> . operation NEQ operation
    (88) compare -> . operation GEQ operation
    (89) compare -> . operation LEQ operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    condition                      shift and go to state 54
    compare                        shift and go to state 32
    operation                      shift and go to state 55
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 25

    (64) assignment -> assign_expr = . matrix
    (65) assignment -> assign_expr = . STRING
    (66) assignment -> assign_expr = . operation
    (26) matrix -> . [ matrix_b ]
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    STRING          shift and go to state 57
    [               shift and go to state 59
    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    matrix                         shift and go to state 56
    operation                      shift and go to state 58
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 26

    (67) assignment -> assign_expr ASSIGNADD . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 60
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 27

    (68) assignment -> assign_expr ASSIGNSUB . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 61
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 28

    (69) assignment -> assign_expr ASSIGNMUL . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 62
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 29

    (70) assignment -> assign_expr ASSIGNDIV . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 63
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 30

    (19) return -> RETURN condition .

    ;               reduce using rule 19 (return -> RETURN condition .)
    {               reduce using rule 19 (return -> RETURN condition .)
    IF              reduce using rule 19 (return -> RETURN condition .)
    RETURN          reduce using rule 19 (return -> RETURN condition .)
    PRINT           reduce using rule 19 (return -> RETURN condition .)
    WHILE           reduce using rule 19 (return -> RETURN condition .)
    FOR             reduce using rule 19 (return -> RETURN condition .)
    ID              reduce using rule 19 (return -> RETURN condition .)
    $end            reduce using rule 19 (return -> RETURN condition .)
    }               reduce using rule 19 (return -> RETURN condition .)
    ELSE            reduce using rule 19 (return -> RETURN condition .)
    BREAK           reduce using rule 19 (return -> RETURN condition .)
    CONTINUE        reduce using rule 19 (return -> RETURN condition .)


state 31

    (20) return -> RETURN operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation
    (84) compare -> operation . < operation
    (85) compare -> operation . > operation
    (86) compare -> operation . EQ operation
    (87) compare -> operation . NEQ operation
    (88) compare -> operation . GEQ operation
    (89) compare -> operation . LEQ operation

    ;               reduce using rule 20 (return -> RETURN operation .)
    {               reduce using rule 20 (return -> RETURN operation .)
    IF              reduce using rule 20 (return -> RETURN operation .)
    RETURN          reduce using rule 20 (return -> RETURN operation .)
    PRINT           reduce using rule 20 (return -> RETURN operation .)
    WHILE           reduce using rule 20 (return -> RETURN operation .)
    FOR             reduce using rule 20 (return -> RETURN operation .)
    ID              reduce using rule 20 (return -> RETURN operation .)
    $end            reduce using rule 20 (return -> RETURN operation .)
    }               reduce using rule 20 (return -> RETURN operation .)
    ELSE            reduce using rule 20 (return -> RETURN operation .)
    BREAK           reduce using rule 20 (return -> RETURN operation .)
    CONTINUE        reduce using rule 20 (return -> RETURN operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71
    <               shift and go to state 72
    >               shift and go to state 73
    EQ              shift and go to state 74
    NEQ             shift and go to state 75
    GEQ             shift and go to state 76
    LEQ             shift and go to state 77


state 32

    (40) condition -> compare .

    ;               reduce using rule 40 (condition -> compare .)
    {               reduce using rule 40 (condition -> compare .)
    IF              reduce using rule 40 (condition -> compare .)
    RETURN          reduce using rule 40 (condition -> compare .)
    PRINT           reduce using rule 40 (condition -> compare .)
    WHILE           reduce using rule 40 (condition -> compare .)
    FOR             reduce using rule 40 (condition -> compare .)
    ID              reduce using rule 40 (condition -> compare .)
    $end            reduce using rule 40 (condition -> compare .)
    }               reduce using rule 40 (condition -> compare .)
    ELSE            reduce using rule 40 (condition -> compare .)
    BREAK           reduce using rule 40 (condition -> compare .)
    CONTINUE        reduce using rule 40 (condition -> compare .)
    )               reduce using rule 40 (condition -> compare .)


state 33

    (11) operation -> number .

    +               reduce using rule 11 (operation -> number .)
    -               reduce using rule 11 (operation -> number .)
    DOTADD          reduce using rule 11 (operation -> number .)
    DOTSUB          reduce using rule 11 (operation -> number .)
    *               reduce using rule 11 (operation -> number .)
    /               reduce using rule 11 (operation -> number .)
    DOTMUL          reduce using rule 11 (operation -> number .)
    DOTDIV          reduce using rule 11 (operation -> number .)
    <               reduce using rule 11 (operation -> number .)
    >               reduce using rule 11 (operation -> number .)
    EQ              reduce using rule 11 (operation -> number .)
    NEQ             reduce using rule 11 (operation -> number .)
    GEQ             reduce using rule 11 (operation -> number .)
    LEQ             reduce using rule 11 (operation -> number .)
    ;               reduce using rule 11 (operation -> number .)
    {               reduce using rule 11 (operation -> number .)
    IF              reduce using rule 11 (operation -> number .)
    RETURN          reduce using rule 11 (operation -> number .)
    PRINT           reduce using rule 11 (operation -> number .)
    WHILE           reduce using rule 11 (operation -> number .)
    FOR             reduce using rule 11 (operation -> number .)
    ID              reduce using rule 11 (operation -> number .)
    $end            reduce using rule 11 (operation -> number .)
    }               reduce using rule 11 (operation -> number .)
    ELSE            reduce using rule 11 (operation -> number .)
    BREAK           reduce using rule 11 (operation -> number .)
    CONTINUE        reduce using rule 11 (operation -> number .)
    ,               reduce using rule 11 (operation -> number .)
    )               reduce using rule 11 (operation -> number .)


state 34

    (12) operation -> unary_operation .

    +               reduce using rule 12 (operation -> unary_operation .)
    -               reduce using rule 12 (operation -> unary_operation .)
    DOTADD          reduce using rule 12 (operation -> unary_operation .)
    DOTSUB          reduce using rule 12 (operation -> unary_operation .)
    *               reduce using rule 12 (operation -> unary_operation .)
    /               reduce using rule 12 (operation -> unary_operation .)
    DOTMUL          reduce using rule 12 (operation -> unary_operation .)
    DOTDIV          reduce using rule 12 (operation -> unary_operation .)
    <               reduce using rule 12 (operation -> unary_operation .)
    >               reduce using rule 12 (operation -> unary_operation .)
    EQ              reduce using rule 12 (operation -> unary_operation .)
    NEQ             reduce using rule 12 (operation -> unary_operation .)
    GEQ             reduce using rule 12 (operation -> unary_operation .)
    LEQ             reduce using rule 12 (operation -> unary_operation .)
    ;               reduce using rule 12 (operation -> unary_operation .)
    {               reduce using rule 12 (operation -> unary_operation .)
    IF              reduce using rule 12 (operation -> unary_operation .)
    RETURN          reduce using rule 12 (operation -> unary_operation .)
    PRINT           reduce using rule 12 (operation -> unary_operation .)
    WHILE           reduce using rule 12 (operation -> unary_operation .)
    FOR             reduce using rule 12 (operation -> unary_operation .)
    ID              reduce using rule 12 (operation -> unary_operation .)
    $end            reduce using rule 12 (operation -> unary_operation .)
    }               reduce using rule 12 (operation -> unary_operation .)
    ELSE            reduce using rule 12 (operation -> unary_operation .)
    BREAK           reduce using rule 12 (operation -> unary_operation .)
    CONTINUE        reduce using rule 12 (operation -> unary_operation .)
    ,               reduce using rule 12 (operation -> unary_operation .)
    )               reduce using rule 12 (operation -> unary_operation .)


state 35

    (13) operation -> function .

    +               reduce using rule 13 (operation -> function .)
    -               reduce using rule 13 (operation -> function .)
    DOTADD          reduce using rule 13 (operation -> function .)
    DOTSUB          reduce using rule 13 (operation -> function .)
    *               reduce using rule 13 (operation -> function .)
    /               reduce using rule 13 (operation -> function .)
    DOTMUL          reduce using rule 13 (operation -> function .)
    DOTDIV          reduce using rule 13 (operation -> function .)
    <               reduce using rule 13 (operation -> function .)
    >               reduce using rule 13 (operation -> function .)
    EQ              reduce using rule 13 (operation -> function .)
    NEQ             reduce using rule 13 (operation -> function .)
    GEQ             reduce using rule 13 (operation -> function .)
    LEQ             reduce using rule 13 (operation -> function .)
    ;               reduce using rule 13 (operation -> function .)
    {               reduce using rule 13 (operation -> function .)
    IF              reduce using rule 13 (operation -> function .)
    RETURN          reduce using rule 13 (operation -> function .)
    PRINT           reduce using rule 13 (operation -> function .)
    WHILE           reduce using rule 13 (operation -> function .)
    FOR             reduce using rule 13 (operation -> function .)
    ID              reduce using rule 13 (operation -> function .)
    $end            reduce using rule 13 (operation -> function .)
    }               reduce using rule 13 (operation -> function .)
    ELSE            reduce using rule 13 (operation -> function .)
    BREAK           reduce using rule 13 (operation -> function .)
    CONTINUE        reduce using rule 13 (operation -> function .)
    ,               reduce using rule 13 (operation -> function .)
    )               reduce using rule 13 (operation -> function .)


state 36

    (73) negation -> - . number
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID

    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 79

    number                         shift and go to state 78

state 37

    (83) operation -> ( . operation )
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 80
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 38

    (30) number -> INTNUM .

    +               reduce using rule 30 (number -> INTNUM .)
    -               reduce using rule 30 (number -> INTNUM .)
    DOTADD          reduce using rule 30 (number -> INTNUM .)
    DOTSUB          reduce using rule 30 (number -> INTNUM .)
    *               reduce using rule 30 (number -> INTNUM .)
    /               reduce using rule 30 (number -> INTNUM .)
    DOTMUL          reduce using rule 30 (number -> INTNUM .)
    DOTDIV          reduce using rule 30 (number -> INTNUM .)
    <               reduce using rule 30 (number -> INTNUM .)
    >               reduce using rule 30 (number -> INTNUM .)
    EQ              reduce using rule 30 (number -> INTNUM .)
    NEQ             reduce using rule 30 (number -> INTNUM .)
    GEQ             reduce using rule 30 (number -> INTNUM .)
    LEQ             reduce using rule 30 (number -> INTNUM .)
    ;               reduce using rule 30 (number -> INTNUM .)
    {               reduce using rule 30 (number -> INTNUM .)
    IF              reduce using rule 30 (number -> INTNUM .)
    RETURN          reduce using rule 30 (number -> INTNUM .)
    PRINT           reduce using rule 30 (number -> INTNUM .)
    WHILE           reduce using rule 30 (number -> INTNUM .)
    FOR             reduce using rule 30 (number -> INTNUM .)
    ID              reduce using rule 30 (number -> INTNUM .)
    $end            reduce using rule 30 (number -> INTNUM .)
    }               reduce using rule 30 (number -> INTNUM .)
    ELSE            reduce using rule 30 (number -> INTNUM .)
    BREAK           reduce using rule 30 (number -> INTNUM .)
    CONTINUE        reduce using rule 30 (number -> INTNUM .)
    ,               reduce using rule 30 (number -> INTNUM .)
    )               reduce using rule 30 (number -> INTNUM .)
    ]               reduce using rule 30 (number -> INTNUM .)


state 39

    (31) number -> FLOATNUM .

    +               reduce using rule 31 (number -> FLOATNUM .)
    -               reduce using rule 31 (number -> FLOATNUM .)
    DOTADD          reduce using rule 31 (number -> FLOATNUM .)
    DOTSUB          reduce using rule 31 (number -> FLOATNUM .)
    *               reduce using rule 31 (number -> FLOATNUM .)
    /               reduce using rule 31 (number -> FLOATNUM .)
    DOTMUL          reduce using rule 31 (number -> FLOATNUM .)
    DOTDIV          reduce using rule 31 (number -> FLOATNUM .)
    <               reduce using rule 31 (number -> FLOATNUM .)
    >               reduce using rule 31 (number -> FLOATNUM .)
    EQ              reduce using rule 31 (number -> FLOATNUM .)
    NEQ             reduce using rule 31 (number -> FLOATNUM .)
    GEQ             reduce using rule 31 (number -> FLOATNUM .)
    LEQ             reduce using rule 31 (number -> FLOATNUM .)
    ;               reduce using rule 31 (number -> FLOATNUM .)
    {               reduce using rule 31 (number -> FLOATNUM .)
    IF              reduce using rule 31 (number -> FLOATNUM .)
    RETURN          reduce using rule 31 (number -> FLOATNUM .)
    PRINT           reduce using rule 31 (number -> FLOATNUM .)
    WHILE           reduce using rule 31 (number -> FLOATNUM .)
    FOR             reduce using rule 31 (number -> FLOATNUM .)
    ID              reduce using rule 31 (number -> FLOATNUM .)
    $end            reduce using rule 31 (number -> FLOATNUM .)
    }               reduce using rule 31 (number -> FLOATNUM .)
    ELSE            reduce using rule 31 (number -> FLOATNUM .)
    BREAK           reduce using rule 31 (number -> FLOATNUM .)
    CONTINUE        reduce using rule 31 (number -> FLOATNUM .)
    ,               reduce using rule 31 (number -> FLOATNUM .)
    )               reduce using rule 31 (number -> FLOATNUM .)
    ]               reduce using rule 31 (number -> FLOATNUM .)


state 40

    (32) number -> ID .
    (74) transpose -> ID . '

    +               reduce using rule 32 (number -> ID .)
    -               reduce using rule 32 (number -> ID .)
    DOTADD          reduce using rule 32 (number -> ID .)
    DOTSUB          reduce using rule 32 (number -> ID .)
    *               reduce using rule 32 (number -> ID .)
    /               reduce using rule 32 (number -> ID .)
    DOTMUL          reduce using rule 32 (number -> ID .)
    DOTDIV          reduce using rule 32 (number -> ID .)
    <               reduce using rule 32 (number -> ID .)
    >               reduce using rule 32 (number -> ID .)
    EQ              reduce using rule 32 (number -> ID .)
    NEQ             reduce using rule 32 (number -> ID .)
    GEQ             reduce using rule 32 (number -> ID .)
    LEQ             reduce using rule 32 (number -> ID .)
    ;               reduce using rule 32 (number -> ID .)
    {               reduce using rule 32 (number -> ID .)
    IF              reduce using rule 32 (number -> ID .)
    RETURN          reduce using rule 32 (number -> ID .)
    PRINT           reduce using rule 32 (number -> ID .)
    WHILE           reduce using rule 32 (number -> ID .)
    FOR             reduce using rule 32 (number -> ID .)
    ID              reduce using rule 32 (number -> ID .)
    $end            reduce using rule 32 (number -> ID .)
    }               reduce using rule 32 (number -> ID .)
    ELSE            reduce using rule 32 (number -> ID .)
    BREAK           reduce using rule 32 (number -> ID .)
    CONTINUE        reduce using rule 32 (number -> ID .)
    ,               reduce using rule 32 (number -> ID .)
    )               reduce using rule 32 (number -> ID .)
    '               shift and go to state 81


state 41

    (71) unary_operation -> negation .

    +               reduce using rule 71 (unary_operation -> negation .)
    -               reduce using rule 71 (unary_operation -> negation .)
    DOTADD          reduce using rule 71 (unary_operation -> negation .)
    DOTSUB          reduce using rule 71 (unary_operation -> negation .)
    *               reduce using rule 71 (unary_operation -> negation .)
    /               reduce using rule 71 (unary_operation -> negation .)
    DOTMUL          reduce using rule 71 (unary_operation -> negation .)
    DOTDIV          reduce using rule 71 (unary_operation -> negation .)
    <               reduce using rule 71 (unary_operation -> negation .)
    >               reduce using rule 71 (unary_operation -> negation .)
    EQ              reduce using rule 71 (unary_operation -> negation .)
    NEQ             reduce using rule 71 (unary_operation -> negation .)
    GEQ             reduce using rule 71 (unary_operation -> negation .)
    LEQ             reduce using rule 71 (unary_operation -> negation .)
    ;               reduce using rule 71 (unary_operation -> negation .)
    {               reduce using rule 71 (unary_operation -> negation .)
    IF              reduce using rule 71 (unary_operation -> negation .)
    RETURN          reduce using rule 71 (unary_operation -> negation .)
    PRINT           reduce using rule 71 (unary_operation -> negation .)
    WHILE           reduce using rule 71 (unary_operation -> negation .)
    FOR             reduce using rule 71 (unary_operation -> negation .)
    ID              reduce using rule 71 (unary_operation -> negation .)
    $end            reduce using rule 71 (unary_operation -> negation .)
    }               reduce using rule 71 (unary_operation -> negation .)
    ELSE            reduce using rule 71 (unary_operation -> negation .)
    BREAK           reduce using rule 71 (unary_operation -> negation .)
    CONTINUE        reduce using rule 71 (unary_operation -> negation .)
    ,               reduce using rule 71 (unary_operation -> negation .)
    )               reduce using rule 71 (unary_operation -> negation .)


state 42

    (72) unary_operation -> transpose .

    +               reduce using rule 72 (unary_operation -> transpose .)
    -               reduce using rule 72 (unary_operation -> transpose .)
    DOTADD          reduce using rule 72 (unary_operation -> transpose .)
    DOTSUB          reduce using rule 72 (unary_operation -> transpose .)
    *               reduce using rule 72 (unary_operation -> transpose .)
    /               reduce using rule 72 (unary_operation -> transpose .)
    DOTMUL          reduce using rule 72 (unary_operation -> transpose .)
    DOTDIV          reduce using rule 72 (unary_operation -> transpose .)
    <               reduce using rule 72 (unary_operation -> transpose .)
    >               reduce using rule 72 (unary_operation -> transpose .)
    EQ              reduce using rule 72 (unary_operation -> transpose .)
    NEQ             reduce using rule 72 (unary_operation -> transpose .)
    GEQ             reduce using rule 72 (unary_operation -> transpose .)
    LEQ             reduce using rule 72 (unary_operation -> transpose .)
    ;               reduce using rule 72 (unary_operation -> transpose .)
    {               reduce using rule 72 (unary_operation -> transpose .)
    IF              reduce using rule 72 (unary_operation -> transpose .)
    RETURN          reduce using rule 72 (unary_operation -> transpose .)
    PRINT           reduce using rule 72 (unary_operation -> transpose .)
    WHILE           reduce using rule 72 (unary_operation -> transpose .)
    FOR             reduce using rule 72 (unary_operation -> transpose .)
    ID              reduce using rule 72 (unary_operation -> transpose .)
    $end            reduce using rule 72 (unary_operation -> transpose .)
    }               reduce using rule 72 (unary_operation -> transpose .)
    ELSE            reduce using rule 72 (unary_operation -> transpose .)
    BREAK           reduce using rule 72 (unary_operation -> transpose .)
    CONTINUE        reduce using rule 72 (unary_operation -> transpose .)
    ,               reduce using rule 72 (unary_operation -> transpose .)
    )               reduce using rule 72 (unary_operation -> transpose .)


state 43

    (36) function -> function_n . ( number )

    (               shift and go to state 82


state 44

    (37) function_n -> ONES .

    (               reduce using rule 37 (function_n -> ONES .)


state 45

    (38) function_n -> EYE .

    (               reduce using rule 38 (function_n -> EYE .)


state 46

    (39) function_n -> ZEROS .

    (               reduce using rule 39 (function_n -> ZEROS .)


state 47

    (15) print -> PRINT print_b .
    (18) print_b -> print_b . , operation

    ;               reduce using rule 15 (print -> PRINT print_b .)
    {               reduce using rule 15 (print -> PRINT print_b .)
    IF              reduce using rule 15 (print -> PRINT print_b .)
    RETURN          reduce using rule 15 (print -> PRINT print_b .)
    PRINT           reduce using rule 15 (print -> PRINT print_b .)
    WHILE           reduce using rule 15 (print -> PRINT print_b .)
    FOR             reduce using rule 15 (print -> PRINT print_b .)
    ID              reduce using rule 15 (print -> PRINT print_b .)
    $end            reduce using rule 15 (print -> PRINT print_b .)
    }               reduce using rule 15 (print -> PRINT print_b .)
    ELSE            reduce using rule 15 (print -> PRINT print_b .)
    BREAK           reduce using rule 15 (print -> PRINT print_b .)
    CONTINUE        reduce using rule 15 (print -> PRINT print_b .)
    ,               shift and go to state 83


state 48

    (16) print_b -> STRING .

    ,               reduce using rule 16 (print_b -> STRING .)
    ;               reduce using rule 16 (print_b -> STRING .)
    {               reduce using rule 16 (print_b -> STRING .)
    IF              reduce using rule 16 (print_b -> STRING .)
    RETURN          reduce using rule 16 (print_b -> STRING .)
    PRINT           reduce using rule 16 (print_b -> STRING .)
    WHILE           reduce using rule 16 (print_b -> STRING .)
    FOR             reduce using rule 16 (print_b -> STRING .)
    ID              reduce using rule 16 (print_b -> STRING .)
    $end            reduce using rule 16 (print_b -> STRING .)
    }               reduce using rule 16 (print_b -> STRING .)
    ELSE            reduce using rule 16 (print_b -> STRING .)
    BREAK           reduce using rule 16 (print_b -> STRING .)
    CONTINUE        reduce using rule 16 (print_b -> STRING .)


state 49

    (17) print_b -> operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ,               reduce using rule 17 (print_b -> operation .)
    ;               reduce using rule 17 (print_b -> operation .)
    {               reduce using rule 17 (print_b -> operation .)
    IF              reduce using rule 17 (print_b -> operation .)
    RETURN          reduce using rule 17 (print_b -> operation .)
    PRINT           reduce using rule 17 (print_b -> operation .)
    WHILE           reduce using rule 17 (print_b -> operation .)
    FOR             reduce using rule 17 (print_b -> operation .)
    ID              reduce using rule 17 (print_b -> operation .)
    $end            reduce using rule 17 (print_b -> operation .)
    }               reduce using rule 17 (print_b -> operation .)
    ELSE            reduce using rule 17 (print_b -> operation .)
    BREAK           reduce using rule 17 (print_b -> operation .)
    CONTINUE        reduce using rule 17 (print_b -> operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 50

    (43) while -> WHILE ( . condition ) loop_b
    (40) condition -> . compare
    (84) compare -> . operation < operation
    (85) compare -> . operation > operation
    (86) compare -> . operation EQ operation
    (87) compare -> . operation NEQ operation
    (88) compare -> . operation GEQ operation
    (89) compare -> . operation LEQ operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    condition                      shift and go to state 84
    compare                        shift and go to state 32
    operation                      shift and go to state 55
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 51

    (44) for -> FOR ID . = int_variable : int_variable loop_b

    =               shift and go to state 85


state 52

    (33) range -> ID [ . int_variable , int_variable ]
    (34) int_variable -> . INTNUM
    (35) int_variable -> . ID

    INTNUM          shift and go to state 88
    ID              shift and go to state 86

    int_variable                   shift and go to state 87

state 53

    (14) c_block -> { m_expr } .

    {               reduce using rule 14 (c_block -> { m_expr } .)
    IF              reduce using rule 14 (c_block -> { m_expr } .)
    RETURN          reduce using rule 14 (c_block -> { m_expr } .)
    PRINT           reduce using rule 14 (c_block -> { m_expr } .)
    WHILE           reduce using rule 14 (c_block -> { m_expr } .)
    FOR             reduce using rule 14 (c_block -> { m_expr } .)
    ID              reduce using rule 14 (c_block -> { m_expr } .)
    $end            reduce using rule 14 (c_block -> { m_expr } .)
    }               reduce using rule 14 (c_block -> { m_expr } .)
    ELSE            reduce using rule 14 (c_block -> { m_expr } .)


state 54

    (55) if_st -> IF ( condition . ) expression else_st

    )               shift and go to state 89


state 55

    (84) compare -> operation . < operation
    (85) compare -> operation . > operation
    (86) compare -> operation . EQ operation
    (87) compare -> operation . NEQ operation
    (88) compare -> operation . GEQ operation
    (89) compare -> operation . LEQ operation
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    <               shift and go to state 72
    >               shift and go to state 73
    EQ              shift and go to state 74
    NEQ             shift and go to state 75
    GEQ             shift and go to state 76
    LEQ             shift and go to state 77
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 56

    (64) assignment -> assign_expr = matrix .

    ;               reduce using rule 64 (assignment -> assign_expr = matrix .)
    {               reduce using rule 64 (assignment -> assign_expr = matrix .)
    IF              reduce using rule 64 (assignment -> assign_expr = matrix .)
    RETURN          reduce using rule 64 (assignment -> assign_expr = matrix .)
    PRINT           reduce using rule 64 (assignment -> assign_expr = matrix .)
    WHILE           reduce using rule 64 (assignment -> assign_expr = matrix .)
    FOR             reduce using rule 64 (assignment -> assign_expr = matrix .)
    ID              reduce using rule 64 (assignment -> assign_expr = matrix .)
    $end            reduce using rule 64 (assignment -> assign_expr = matrix .)
    }               reduce using rule 64 (assignment -> assign_expr = matrix .)
    ELSE            reduce using rule 64 (assignment -> assign_expr = matrix .)
    BREAK           reduce using rule 64 (assignment -> assign_expr = matrix .)
    CONTINUE        reduce using rule 64 (assignment -> assign_expr = matrix .)


state 57

    (65) assignment -> assign_expr = STRING .

    ;               reduce using rule 65 (assignment -> assign_expr = STRING .)
    {               reduce using rule 65 (assignment -> assign_expr = STRING .)
    IF              reduce using rule 65 (assignment -> assign_expr = STRING .)
    RETURN          reduce using rule 65 (assignment -> assign_expr = STRING .)
    PRINT           reduce using rule 65 (assignment -> assign_expr = STRING .)
    WHILE           reduce using rule 65 (assignment -> assign_expr = STRING .)
    FOR             reduce using rule 65 (assignment -> assign_expr = STRING .)
    ID              reduce using rule 65 (assignment -> assign_expr = STRING .)
    $end            reduce using rule 65 (assignment -> assign_expr = STRING .)
    }               reduce using rule 65 (assignment -> assign_expr = STRING .)
    ELSE            reduce using rule 65 (assignment -> assign_expr = STRING .)
    BREAK           reduce using rule 65 (assignment -> assign_expr = STRING .)
    CONTINUE        reduce using rule 65 (assignment -> assign_expr = STRING .)


state 58

    (66) assignment -> assign_expr = operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 66 (assignment -> assign_expr = operation .)
    {               reduce using rule 66 (assignment -> assign_expr = operation .)
    IF              reduce using rule 66 (assignment -> assign_expr = operation .)
    RETURN          reduce using rule 66 (assignment -> assign_expr = operation .)
    PRINT           reduce using rule 66 (assignment -> assign_expr = operation .)
    WHILE           reduce using rule 66 (assignment -> assign_expr = operation .)
    FOR             reduce using rule 66 (assignment -> assign_expr = operation .)
    ID              reduce using rule 66 (assignment -> assign_expr = operation .)
    $end            reduce using rule 66 (assignment -> assign_expr = operation .)
    }               reduce using rule 66 (assignment -> assign_expr = operation .)
    ELSE            reduce using rule 66 (assignment -> assign_expr = operation .)
    BREAK           reduce using rule 66 (assignment -> assign_expr = operation .)
    CONTINUE        reduce using rule 66 (assignment -> assign_expr = operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 59

    (26) matrix -> [ . matrix_b ]
    (27) matrix_b -> . array
    (28) matrix_b -> . matrix_b , array
    (29) matrix_b -> . eps
    (22) array -> . [ array_b ]
    (61) eps -> .

    [               shift and go to state 90
    ]               reduce using rule 61 (eps -> .)
    ,               reduce using rule 61 (eps -> .)

    matrix_b                       shift and go to state 91
    array                          shift and go to state 92
    eps                            shift and go to state 93

state 60

    (67) assignment -> assign_expr ASSIGNADD operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    {               reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    IF              reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    RETURN          reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    PRINT           reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    WHILE           reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    FOR             reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    ID              reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    $end            reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    }               reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    ELSE            reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    BREAK           reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    CONTINUE        reduce using rule 67 (assignment -> assign_expr ASSIGNADD operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 61

    (68) assignment -> assign_expr ASSIGNSUB operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    {               reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    IF              reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    RETURN          reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    PRINT           reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    WHILE           reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    FOR             reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    ID              reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    $end            reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    }               reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    ELSE            reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    BREAK           reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    CONTINUE        reduce using rule 68 (assignment -> assign_expr ASSIGNSUB operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 62

    (69) assignment -> assign_expr ASSIGNMUL operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    {               reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    IF              reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    RETURN          reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    PRINT           reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    WHILE           reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    FOR             reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    ID              reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    $end            reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    }               reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    ELSE            reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    BREAK           reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    CONTINUE        reduce using rule 69 (assignment -> assign_expr ASSIGNMUL operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 63

    (70) assignment -> assign_expr ASSIGNDIV operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    {               reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    IF              reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    RETURN          reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    PRINT           reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    WHILE           reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    FOR             reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    ID              reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    $end            reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    }               reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    ELSE            reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    BREAK           reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    CONTINUE        reduce using rule 70 (assignment -> assign_expr ASSIGNDIV operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 64

    (75) operation -> operation + . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 94
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 65

    (76) operation -> operation - . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 95
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 66

    (77) operation -> operation DOTADD . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 96
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 67

    (78) operation -> operation DOTSUB . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 97
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 68

    (79) operation -> operation * . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 98
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 69

    (80) operation -> operation / . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 99
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 70

    (81) operation -> operation DOTMUL . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 100
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 71

    (82) operation -> operation DOTDIV . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 101
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 72

    (84) compare -> operation < . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 102
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 73

    (85) compare -> operation > . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 103
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 74

    (86) compare -> operation EQ . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 104
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 75

    (87) compare -> operation NEQ . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 105
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 76

    (88) compare -> operation GEQ . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 106
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 77

    (89) compare -> operation LEQ . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 107
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 78

    (73) negation -> - number .

    +               reduce using rule 73 (negation -> - number .)
    -               reduce using rule 73 (negation -> - number .)
    DOTADD          reduce using rule 73 (negation -> - number .)
    DOTSUB          reduce using rule 73 (negation -> - number .)
    *               reduce using rule 73 (negation -> - number .)
    /               reduce using rule 73 (negation -> - number .)
    DOTMUL          reduce using rule 73 (negation -> - number .)
    DOTDIV          reduce using rule 73 (negation -> - number .)
    <               reduce using rule 73 (negation -> - number .)
    >               reduce using rule 73 (negation -> - number .)
    EQ              reduce using rule 73 (negation -> - number .)
    NEQ             reduce using rule 73 (negation -> - number .)
    GEQ             reduce using rule 73 (negation -> - number .)
    LEQ             reduce using rule 73 (negation -> - number .)
    ;               reduce using rule 73 (negation -> - number .)
    {               reduce using rule 73 (negation -> - number .)
    IF              reduce using rule 73 (negation -> - number .)
    RETURN          reduce using rule 73 (negation -> - number .)
    PRINT           reduce using rule 73 (negation -> - number .)
    WHILE           reduce using rule 73 (negation -> - number .)
    FOR             reduce using rule 73 (negation -> - number .)
    ID              reduce using rule 73 (negation -> - number .)
    $end            reduce using rule 73 (negation -> - number .)
    }               reduce using rule 73 (negation -> - number .)
    ELSE            reduce using rule 73 (negation -> - number .)
    BREAK           reduce using rule 73 (negation -> - number .)
    CONTINUE        reduce using rule 73 (negation -> - number .)
    ,               reduce using rule 73 (negation -> - number .)
    )               reduce using rule 73 (negation -> - number .)


state 79

    (32) number -> ID .

    +               reduce using rule 32 (number -> ID .)
    -               reduce using rule 32 (number -> ID .)
    DOTADD          reduce using rule 32 (number -> ID .)
    DOTSUB          reduce using rule 32 (number -> ID .)
    *               reduce using rule 32 (number -> ID .)
    /               reduce using rule 32 (number -> ID .)
    DOTMUL          reduce using rule 32 (number -> ID .)
    DOTDIV          reduce using rule 32 (number -> ID .)
    <               reduce using rule 32 (number -> ID .)
    >               reduce using rule 32 (number -> ID .)
    EQ              reduce using rule 32 (number -> ID .)
    NEQ             reduce using rule 32 (number -> ID .)
    GEQ             reduce using rule 32 (number -> ID .)
    LEQ             reduce using rule 32 (number -> ID .)
    ;               reduce using rule 32 (number -> ID .)
    {               reduce using rule 32 (number -> ID .)
    IF              reduce using rule 32 (number -> ID .)
    RETURN          reduce using rule 32 (number -> ID .)
    PRINT           reduce using rule 32 (number -> ID .)
    WHILE           reduce using rule 32 (number -> ID .)
    FOR             reduce using rule 32 (number -> ID .)
    ID              reduce using rule 32 (number -> ID .)
    $end            reduce using rule 32 (number -> ID .)
    }               reduce using rule 32 (number -> ID .)
    ELSE            reduce using rule 32 (number -> ID .)
    BREAK           reduce using rule 32 (number -> ID .)
    CONTINUE        reduce using rule 32 (number -> ID .)
    ,               reduce using rule 32 (number -> ID .)
    )               reduce using rule 32 (number -> ID .)
    ]               reduce using rule 32 (number -> ID .)


state 80

    (83) operation -> ( operation . )
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    )               shift and go to state 108
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 81

    (74) transpose -> ID ' .

    +               reduce using rule 74 (transpose -> ID ' .)
    -               reduce using rule 74 (transpose -> ID ' .)
    DOTADD          reduce using rule 74 (transpose -> ID ' .)
    DOTSUB          reduce using rule 74 (transpose -> ID ' .)
    *               reduce using rule 74 (transpose -> ID ' .)
    /               reduce using rule 74 (transpose -> ID ' .)
    DOTMUL          reduce using rule 74 (transpose -> ID ' .)
    DOTDIV          reduce using rule 74 (transpose -> ID ' .)
    <               reduce using rule 74 (transpose -> ID ' .)
    >               reduce using rule 74 (transpose -> ID ' .)
    EQ              reduce using rule 74 (transpose -> ID ' .)
    NEQ             reduce using rule 74 (transpose -> ID ' .)
    GEQ             reduce using rule 74 (transpose -> ID ' .)
    LEQ             reduce using rule 74 (transpose -> ID ' .)
    ;               reduce using rule 74 (transpose -> ID ' .)
    {               reduce using rule 74 (transpose -> ID ' .)
    IF              reduce using rule 74 (transpose -> ID ' .)
    RETURN          reduce using rule 74 (transpose -> ID ' .)
    PRINT           reduce using rule 74 (transpose -> ID ' .)
    WHILE           reduce using rule 74 (transpose -> ID ' .)
    FOR             reduce using rule 74 (transpose -> ID ' .)
    ID              reduce using rule 74 (transpose -> ID ' .)
    $end            reduce using rule 74 (transpose -> ID ' .)
    }               reduce using rule 74 (transpose -> ID ' .)
    ELSE            reduce using rule 74 (transpose -> ID ' .)
    BREAK           reduce using rule 74 (transpose -> ID ' .)
    CONTINUE        reduce using rule 74 (transpose -> ID ' .)
    ,               reduce using rule 74 (transpose -> ID ' .)
    )               reduce using rule 74 (transpose -> ID ' .)


state 82

    (36) function -> function_n ( . number )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID

    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 79

    number                         shift and go to state 109

state 83

    (18) print_b -> print_b , . operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    operation                      shift and go to state 110
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 84

    (43) while -> WHILE ( condition . ) loop_b

    )               shift and go to state 111


state 85

    (44) for -> FOR ID = . int_variable : int_variable loop_b
    (34) int_variable -> . INTNUM
    (35) int_variable -> . ID

    INTNUM          shift and go to state 88
    ID              shift and go to state 86

    int_variable                   shift and go to state 112

state 86

    (35) int_variable -> ID .

    ,               reduce using rule 35 (int_variable -> ID .)
    :               reduce using rule 35 (int_variable -> ID .)
    ]               reduce using rule 35 (int_variable -> ID .)
    {               reduce using rule 35 (int_variable -> ID .)
    BREAK           reduce using rule 35 (int_variable -> ID .)
    CONTINUE        reduce using rule 35 (int_variable -> ID .)
    IF              reduce using rule 35 (int_variable -> ID .)
    RETURN          reduce using rule 35 (int_variable -> ID .)
    PRINT           reduce using rule 35 (int_variable -> ID .)
    WHILE           reduce using rule 35 (int_variable -> ID .)
    FOR             reduce using rule 35 (int_variable -> ID .)
    ID              reduce using rule 35 (int_variable -> ID .)


state 87

    (33) range -> ID [ int_variable . , int_variable ]

    ,               shift and go to state 113


state 88

    (34) int_variable -> INTNUM .

    ,               reduce using rule 34 (int_variable -> INTNUM .)
    :               reduce using rule 34 (int_variable -> INTNUM .)
    ]               reduce using rule 34 (int_variable -> INTNUM .)
    {               reduce using rule 34 (int_variable -> INTNUM .)
    BREAK           reduce using rule 34 (int_variable -> INTNUM .)
    CONTINUE        reduce using rule 34 (int_variable -> INTNUM .)
    IF              reduce using rule 34 (int_variable -> INTNUM .)
    RETURN          reduce using rule 34 (int_variable -> INTNUM .)
    PRINT           reduce using rule 34 (int_variable -> INTNUM .)
    WHILE           reduce using rule 34 (int_variable -> INTNUM .)
    FOR             reduce using rule 34 (int_variable -> INTNUM .)
    ID              reduce using rule 34 (int_variable -> INTNUM .)


state 89

    (55) if_st -> IF ( condition ) . expression else_st
    (3) expression -> . c_block
    (4) expression -> . base_expr
    (5) expression -> . base_expr ;
    (6) expression -> . if_st
    (7) expression -> . loop_st
    (14) c_block -> . { m_expr }
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (55) if_st -> . IF ( condition ) expression else_st
    (41) loop_st -> . while
    (42) loop_st -> . for
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    {               shift and go to state 7
    IF              shift and go to state 11
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    expression                     shift and go to state 114
    c_block                        shift and go to state 3
    base_expr                      shift and go to state 4
    if_st                          shift and go to state 5
    loop_st                        shift and go to state 6
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 90

    (22) array -> [ . array_b ]
    (23) array_b -> . number
    (24) array_b -> . array_b , number
    (25) array_b -> . eps
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (61) eps -> .

    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 79
    ]               reduce using rule 61 (eps -> .)
    ,               reduce using rule 61 (eps -> .)

    array_b                        shift and go to state 115
    number                         shift and go to state 116
    eps                            shift and go to state 117

state 91

    (26) matrix -> [ matrix_b . ]
    (28) matrix_b -> matrix_b . , array

    ]               shift and go to state 118
    ,               shift and go to state 119


state 92

    (27) matrix_b -> array .

    ]               reduce using rule 27 (matrix_b -> array .)
    ,               reduce using rule 27 (matrix_b -> array .)


state 93

    (29) matrix_b -> eps .

    ]               reduce using rule 29 (matrix_b -> eps .)
    ,               reduce using rule 29 (matrix_b -> eps .)


state 94

    (75) operation -> operation + operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    +               reduce using rule 75 (operation -> operation + operation .)
    -               reduce using rule 75 (operation -> operation + operation .)
    <               reduce using rule 75 (operation -> operation + operation .)
    >               reduce using rule 75 (operation -> operation + operation .)
    EQ              reduce using rule 75 (operation -> operation + operation .)
    NEQ             reduce using rule 75 (operation -> operation + operation .)
    GEQ             reduce using rule 75 (operation -> operation + operation .)
    LEQ             reduce using rule 75 (operation -> operation + operation .)
    ;               reduce using rule 75 (operation -> operation + operation .)
    {               reduce using rule 75 (operation -> operation + operation .)
    IF              reduce using rule 75 (operation -> operation + operation .)
    RETURN          reduce using rule 75 (operation -> operation + operation .)
    PRINT           reduce using rule 75 (operation -> operation + operation .)
    WHILE           reduce using rule 75 (operation -> operation + operation .)
    FOR             reduce using rule 75 (operation -> operation + operation .)
    ID              reduce using rule 75 (operation -> operation + operation .)
    $end            reduce using rule 75 (operation -> operation + operation .)
    }               reduce using rule 75 (operation -> operation + operation .)
    ELSE            reduce using rule 75 (operation -> operation + operation .)
    BREAK           reduce using rule 75 (operation -> operation + operation .)
    CONTINUE        reduce using rule 75 (operation -> operation + operation .)
    ,               reduce using rule 75 (operation -> operation + operation .)
    )               reduce using rule 75 (operation -> operation + operation .)
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71

  ! DOTADD          [ reduce using rule 75 (operation -> operation + operation .) ]
  ! DOTSUB          [ reduce using rule 75 (operation -> operation + operation .) ]
  ! *               [ reduce using rule 75 (operation -> operation + operation .) ]
  ! /               [ reduce using rule 75 (operation -> operation + operation .) ]
  ! DOTMUL          [ reduce using rule 75 (operation -> operation + operation .) ]
  ! DOTDIV          [ reduce using rule 75 (operation -> operation + operation .) ]
  ! +               [ shift and go to state 64 ]
  ! -               [ shift and go to state 65 ]


state 95

    (76) operation -> operation - operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    +               reduce using rule 76 (operation -> operation - operation .)
    -               reduce using rule 76 (operation -> operation - operation .)
    <               reduce using rule 76 (operation -> operation - operation .)
    >               reduce using rule 76 (operation -> operation - operation .)
    EQ              reduce using rule 76 (operation -> operation - operation .)
    NEQ             reduce using rule 76 (operation -> operation - operation .)
    GEQ             reduce using rule 76 (operation -> operation - operation .)
    LEQ             reduce using rule 76 (operation -> operation - operation .)
    ;               reduce using rule 76 (operation -> operation - operation .)
    {               reduce using rule 76 (operation -> operation - operation .)
    IF              reduce using rule 76 (operation -> operation - operation .)
    RETURN          reduce using rule 76 (operation -> operation - operation .)
    PRINT           reduce using rule 76 (operation -> operation - operation .)
    WHILE           reduce using rule 76 (operation -> operation - operation .)
    FOR             reduce using rule 76 (operation -> operation - operation .)
    ID              reduce using rule 76 (operation -> operation - operation .)
    $end            reduce using rule 76 (operation -> operation - operation .)
    }               reduce using rule 76 (operation -> operation - operation .)
    ELSE            reduce using rule 76 (operation -> operation - operation .)
    BREAK           reduce using rule 76 (operation -> operation - operation .)
    CONTINUE        reduce using rule 76 (operation -> operation - operation .)
    ,               reduce using rule 76 (operation -> operation - operation .)
    )               reduce using rule 76 (operation -> operation - operation .)
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71

  ! DOTADD          [ reduce using rule 76 (operation -> operation - operation .) ]
  ! DOTSUB          [ reduce using rule 76 (operation -> operation - operation .) ]
  ! *               [ reduce using rule 76 (operation -> operation - operation .) ]
  ! /               [ reduce using rule 76 (operation -> operation - operation .) ]
  ! DOTMUL          [ reduce using rule 76 (operation -> operation - operation .) ]
  ! DOTDIV          [ reduce using rule 76 (operation -> operation - operation .) ]
  ! +               [ shift and go to state 64 ]
  ! -               [ shift and go to state 65 ]


state 96

    (77) operation -> operation DOTADD operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    +               reduce using rule 77 (operation -> operation DOTADD operation .)
    -               reduce using rule 77 (operation -> operation DOTADD operation .)
    DOTADD          reduce using rule 77 (operation -> operation DOTADD operation .)
    DOTSUB          reduce using rule 77 (operation -> operation DOTADD operation .)
    <               reduce using rule 77 (operation -> operation DOTADD operation .)
    >               reduce using rule 77 (operation -> operation DOTADD operation .)
    EQ              reduce using rule 77 (operation -> operation DOTADD operation .)
    NEQ             reduce using rule 77 (operation -> operation DOTADD operation .)
    GEQ             reduce using rule 77 (operation -> operation DOTADD operation .)
    LEQ             reduce using rule 77 (operation -> operation DOTADD operation .)
    ;               reduce using rule 77 (operation -> operation DOTADD operation .)
    {               reduce using rule 77 (operation -> operation DOTADD operation .)
    IF              reduce using rule 77 (operation -> operation DOTADD operation .)
    RETURN          reduce using rule 77 (operation -> operation DOTADD operation .)
    PRINT           reduce using rule 77 (operation -> operation DOTADD operation .)
    WHILE           reduce using rule 77 (operation -> operation DOTADD operation .)
    FOR             reduce using rule 77 (operation -> operation DOTADD operation .)
    ID              reduce using rule 77 (operation -> operation DOTADD operation .)
    $end            reduce using rule 77 (operation -> operation DOTADD operation .)
    }               reduce using rule 77 (operation -> operation DOTADD operation .)
    ELSE            reduce using rule 77 (operation -> operation DOTADD operation .)
    BREAK           reduce using rule 77 (operation -> operation DOTADD operation .)
    CONTINUE        reduce using rule 77 (operation -> operation DOTADD operation .)
    ,               reduce using rule 77 (operation -> operation DOTADD operation .)
    )               reduce using rule 77 (operation -> operation DOTADD operation .)
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71

  ! *               [ reduce using rule 77 (operation -> operation DOTADD operation .) ]
  ! /               [ reduce using rule 77 (operation -> operation DOTADD operation .) ]
  ! DOTMUL          [ reduce using rule 77 (operation -> operation DOTADD operation .) ]
  ! DOTDIV          [ reduce using rule 77 (operation -> operation DOTADD operation .) ]
  ! +               [ shift and go to state 64 ]
  ! -               [ shift and go to state 65 ]
  ! DOTADD          [ shift and go to state 66 ]
  ! DOTSUB          [ shift and go to state 67 ]


state 97

    (78) operation -> operation DOTSUB operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    +               reduce using rule 78 (operation -> operation DOTSUB operation .)
    -               reduce using rule 78 (operation -> operation DOTSUB operation .)
    DOTADD          reduce using rule 78 (operation -> operation DOTSUB operation .)
    DOTSUB          reduce using rule 78 (operation -> operation DOTSUB operation .)
    <               reduce using rule 78 (operation -> operation DOTSUB operation .)
    >               reduce using rule 78 (operation -> operation DOTSUB operation .)
    EQ              reduce using rule 78 (operation -> operation DOTSUB operation .)
    NEQ             reduce using rule 78 (operation -> operation DOTSUB operation .)
    GEQ             reduce using rule 78 (operation -> operation DOTSUB operation .)
    LEQ             reduce using rule 78 (operation -> operation DOTSUB operation .)
    ;               reduce using rule 78 (operation -> operation DOTSUB operation .)
    {               reduce using rule 78 (operation -> operation DOTSUB operation .)
    IF              reduce using rule 78 (operation -> operation DOTSUB operation .)
    RETURN          reduce using rule 78 (operation -> operation DOTSUB operation .)
    PRINT           reduce using rule 78 (operation -> operation DOTSUB operation .)
    WHILE           reduce using rule 78 (operation -> operation DOTSUB operation .)
    FOR             reduce using rule 78 (operation -> operation DOTSUB operation .)
    ID              reduce using rule 78 (operation -> operation DOTSUB operation .)
    $end            reduce using rule 78 (operation -> operation DOTSUB operation .)
    }               reduce using rule 78 (operation -> operation DOTSUB operation .)
    ELSE            reduce using rule 78 (operation -> operation DOTSUB operation .)
    BREAK           reduce using rule 78 (operation -> operation DOTSUB operation .)
    CONTINUE        reduce using rule 78 (operation -> operation DOTSUB operation .)
    ,               reduce using rule 78 (operation -> operation DOTSUB operation .)
    )               reduce using rule 78 (operation -> operation DOTSUB operation .)
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71

  ! *               [ reduce using rule 78 (operation -> operation DOTSUB operation .) ]
  ! /               [ reduce using rule 78 (operation -> operation DOTSUB operation .) ]
  ! DOTMUL          [ reduce using rule 78 (operation -> operation DOTSUB operation .) ]
  ! DOTDIV          [ reduce using rule 78 (operation -> operation DOTSUB operation .) ]
  ! +               [ shift and go to state 64 ]
  ! -               [ shift and go to state 65 ]
  ! DOTADD          [ shift and go to state 66 ]
  ! DOTSUB          [ shift and go to state 67 ]


state 98

    (79) operation -> operation * operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    +               reduce using rule 79 (operation -> operation * operation .)
    -               reduce using rule 79 (operation -> operation * operation .)
    DOTADD          reduce using rule 79 (operation -> operation * operation .)
    DOTSUB          reduce using rule 79 (operation -> operation * operation .)
    *               reduce using rule 79 (operation -> operation * operation .)
    /               reduce using rule 79 (operation -> operation * operation .)
    <               reduce using rule 79 (operation -> operation * operation .)
    >               reduce using rule 79 (operation -> operation * operation .)
    EQ              reduce using rule 79 (operation -> operation * operation .)
    NEQ             reduce using rule 79 (operation -> operation * operation .)
    GEQ             reduce using rule 79 (operation -> operation * operation .)
    LEQ             reduce using rule 79 (operation -> operation * operation .)
    ;               reduce using rule 79 (operation -> operation * operation .)
    {               reduce using rule 79 (operation -> operation * operation .)
    IF              reduce using rule 79 (operation -> operation * operation .)
    RETURN          reduce using rule 79 (operation -> operation * operation .)
    PRINT           reduce using rule 79 (operation -> operation * operation .)
    WHILE           reduce using rule 79 (operation -> operation * operation .)
    FOR             reduce using rule 79 (operation -> operation * operation .)
    ID              reduce using rule 79 (operation -> operation * operation .)
    $end            reduce using rule 79 (operation -> operation * operation .)
    }               reduce using rule 79 (operation -> operation * operation .)
    ELSE            reduce using rule 79 (operation -> operation * operation .)
    BREAK           reduce using rule 79 (operation -> operation * operation .)
    CONTINUE        reduce using rule 79 (operation -> operation * operation .)
    ,               reduce using rule 79 (operation -> operation * operation .)
    )               reduce using rule 79 (operation -> operation * operation .)
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71

  ! DOTMUL          [ reduce using rule 79 (operation -> operation * operation .) ]
  ! DOTDIV          [ reduce using rule 79 (operation -> operation * operation .) ]
  ! +               [ shift and go to state 64 ]
  ! -               [ shift and go to state 65 ]
  ! DOTADD          [ shift and go to state 66 ]
  ! DOTSUB          [ shift and go to state 67 ]
  ! *               [ shift and go to state 68 ]
  ! /               [ shift and go to state 69 ]


state 99

    (80) operation -> operation / operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    +               reduce using rule 80 (operation -> operation / operation .)
    -               reduce using rule 80 (operation -> operation / operation .)
    DOTADD          reduce using rule 80 (operation -> operation / operation .)
    DOTSUB          reduce using rule 80 (operation -> operation / operation .)
    *               reduce using rule 80 (operation -> operation / operation .)
    /               reduce using rule 80 (operation -> operation / operation .)
    <               reduce using rule 80 (operation -> operation / operation .)
    >               reduce using rule 80 (operation -> operation / operation .)
    EQ              reduce using rule 80 (operation -> operation / operation .)
    NEQ             reduce using rule 80 (operation -> operation / operation .)
    GEQ             reduce using rule 80 (operation -> operation / operation .)
    LEQ             reduce using rule 80 (operation -> operation / operation .)
    ;               reduce using rule 80 (operation -> operation / operation .)
    {               reduce using rule 80 (operation -> operation / operation .)
    IF              reduce using rule 80 (operation -> operation / operation .)
    RETURN          reduce using rule 80 (operation -> operation / operation .)
    PRINT           reduce using rule 80 (operation -> operation / operation .)
    WHILE           reduce using rule 80 (operation -> operation / operation .)
    FOR             reduce using rule 80 (operation -> operation / operation .)
    ID              reduce using rule 80 (operation -> operation / operation .)
    $end            reduce using rule 80 (operation -> operation / operation .)
    }               reduce using rule 80 (operation -> operation / operation .)
    ELSE            reduce using rule 80 (operation -> operation / operation .)
    BREAK           reduce using rule 80 (operation -> operation / operation .)
    CONTINUE        reduce using rule 80 (operation -> operation / operation .)
    ,               reduce using rule 80 (operation -> operation / operation .)
    )               reduce using rule 80 (operation -> operation / operation .)
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71

  ! DOTMUL          [ reduce using rule 80 (operation -> operation / operation .) ]
  ! DOTDIV          [ reduce using rule 80 (operation -> operation / operation .) ]
  ! +               [ shift and go to state 64 ]
  ! -               [ shift and go to state 65 ]
  ! DOTADD          [ shift and go to state 66 ]
  ! DOTSUB          [ shift and go to state 67 ]
  ! *               [ shift and go to state 68 ]
  ! /               [ shift and go to state 69 ]


state 100

    (81) operation -> operation DOTMUL operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    +               reduce using rule 81 (operation -> operation DOTMUL operation .)
    -               reduce using rule 81 (operation -> operation DOTMUL operation .)
    DOTADD          reduce using rule 81 (operation -> operation DOTMUL operation .)
    DOTSUB          reduce using rule 81 (operation -> operation DOTMUL operation .)
    *               reduce using rule 81 (operation -> operation DOTMUL operation .)
    /               reduce using rule 81 (operation -> operation DOTMUL operation .)
    DOTMUL          reduce using rule 81 (operation -> operation DOTMUL operation .)
    DOTDIV          reduce using rule 81 (operation -> operation DOTMUL operation .)
    <               reduce using rule 81 (operation -> operation DOTMUL operation .)
    >               reduce using rule 81 (operation -> operation DOTMUL operation .)
    EQ              reduce using rule 81 (operation -> operation DOTMUL operation .)
    NEQ             reduce using rule 81 (operation -> operation DOTMUL operation .)
    GEQ             reduce using rule 81 (operation -> operation DOTMUL operation .)
    LEQ             reduce using rule 81 (operation -> operation DOTMUL operation .)
    ;               reduce using rule 81 (operation -> operation DOTMUL operation .)
    {               reduce using rule 81 (operation -> operation DOTMUL operation .)
    IF              reduce using rule 81 (operation -> operation DOTMUL operation .)
    RETURN          reduce using rule 81 (operation -> operation DOTMUL operation .)
    PRINT           reduce using rule 81 (operation -> operation DOTMUL operation .)
    WHILE           reduce using rule 81 (operation -> operation DOTMUL operation .)
    FOR             reduce using rule 81 (operation -> operation DOTMUL operation .)
    ID              reduce using rule 81 (operation -> operation DOTMUL operation .)
    $end            reduce using rule 81 (operation -> operation DOTMUL operation .)
    }               reduce using rule 81 (operation -> operation DOTMUL operation .)
    ELSE            reduce using rule 81 (operation -> operation DOTMUL operation .)
    BREAK           reduce using rule 81 (operation -> operation DOTMUL operation .)
    CONTINUE        reduce using rule 81 (operation -> operation DOTMUL operation .)
    ,               reduce using rule 81 (operation -> operation DOTMUL operation .)
    )               reduce using rule 81 (operation -> operation DOTMUL operation .)

  ! +               [ shift and go to state 64 ]
  ! -               [ shift and go to state 65 ]
  ! DOTADD          [ shift and go to state 66 ]
  ! DOTSUB          [ shift and go to state 67 ]
  ! *               [ shift and go to state 68 ]
  ! /               [ shift and go to state 69 ]
  ! DOTMUL          [ shift and go to state 70 ]
  ! DOTDIV          [ shift and go to state 71 ]


state 101

    (82) operation -> operation DOTDIV operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    +               reduce using rule 82 (operation -> operation DOTDIV operation .)
    -               reduce using rule 82 (operation -> operation DOTDIV operation .)
    DOTADD          reduce using rule 82 (operation -> operation DOTDIV operation .)
    DOTSUB          reduce using rule 82 (operation -> operation DOTDIV operation .)
    *               reduce using rule 82 (operation -> operation DOTDIV operation .)
    /               reduce using rule 82 (operation -> operation DOTDIV operation .)
    DOTMUL          reduce using rule 82 (operation -> operation DOTDIV operation .)
    DOTDIV          reduce using rule 82 (operation -> operation DOTDIV operation .)
    <               reduce using rule 82 (operation -> operation DOTDIV operation .)
    >               reduce using rule 82 (operation -> operation DOTDIV operation .)
    EQ              reduce using rule 82 (operation -> operation DOTDIV operation .)
    NEQ             reduce using rule 82 (operation -> operation DOTDIV operation .)
    GEQ             reduce using rule 82 (operation -> operation DOTDIV operation .)
    LEQ             reduce using rule 82 (operation -> operation DOTDIV operation .)
    ;               reduce using rule 82 (operation -> operation DOTDIV operation .)
    {               reduce using rule 82 (operation -> operation DOTDIV operation .)
    IF              reduce using rule 82 (operation -> operation DOTDIV operation .)
    RETURN          reduce using rule 82 (operation -> operation DOTDIV operation .)
    PRINT           reduce using rule 82 (operation -> operation DOTDIV operation .)
    WHILE           reduce using rule 82 (operation -> operation DOTDIV operation .)
    FOR             reduce using rule 82 (operation -> operation DOTDIV operation .)
    ID              reduce using rule 82 (operation -> operation DOTDIV operation .)
    $end            reduce using rule 82 (operation -> operation DOTDIV operation .)
    }               reduce using rule 82 (operation -> operation DOTDIV operation .)
    ELSE            reduce using rule 82 (operation -> operation DOTDIV operation .)
    BREAK           reduce using rule 82 (operation -> operation DOTDIV operation .)
    CONTINUE        reduce using rule 82 (operation -> operation DOTDIV operation .)
    ,               reduce using rule 82 (operation -> operation DOTDIV operation .)
    )               reduce using rule 82 (operation -> operation DOTDIV operation .)

  ! +               [ shift and go to state 64 ]
  ! -               [ shift and go to state 65 ]
  ! DOTADD          [ shift and go to state 66 ]
  ! DOTSUB          [ shift and go to state 67 ]
  ! *               [ shift and go to state 68 ]
  ! /               [ shift and go to state 69 ]
  ! DOTMUL          [ shift and go to state 70 ]
  ! DOTDIV          [ shift and go to state 71 ]


state 102

    (84) compare -> operation < operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 84 (compare -> operation < operation .)
    {               reduce using rule 84 (compare -> operation < operation .)
    IF              reduce using rule 84 (compare -> operation < operation .)
    RETURN          reduce using rule 84 (compare -> operation < operation .)
    PRINT           reduce using rule 84 (compare -> operation < operation .)
    WHILE           reduce using rule 84 (compare -> operation < operation .)
    FOR             reduce using rule 84 (compare -> operation < operation .)
    ID              reduce using rule 84 (compare -> operation < operation .)
    $end            reduce using rule 84 (compare -> operation < operation .)
    }               reduce using rule 84 (compare -> operation < operation .)
    ELSE            reduce using rule 84 (compare -> operation < operation .)
    BREAK           reduce using rule 84 (compare -> operation < operation .)
    CONTINUE        reduce using rule 84 (compare -> operation < operation .)
    )               reduce using rule 84 (compare -> operation < operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 103

    (85) compare -> operation > operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 85 (compare -> operation > operation .)
    {               reduce using rule 85 (compare -> operation > operation .)
    IF              reduce using rule 85 (compare -> operation > operation .)
    RETURN          reduce using rule 85 (compare -> operation > operation .)
    PRINT           reduce using rule 85 (compare -> operation > operation .)
    WHILE           reduce using rule 85 (compare -> operation > operation .)
    FOR             reduce using rule 85 (compare -> operation > operation .)
    ID              reduce using rule 85 (compare -> operation > operation .)
    $end            reduce using rule 85 (compare -> operation > operation .)
    }               reduce using rule 85 (compare -> operation > operation .)
    ELSE            reduce using rule 85 (compare -> operation > operation .)
    BREAK           reduce using rule 85 (compare -> operation > operation .)
    CONTINUE        reduce using rule 85 (compare -> operation > operation .)
    )               reduce using rule 85 (compare -> operation > operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 104

    (86) compare -> operation EQ operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 86 (compare -> operation EQ operation .)
    {               reduce using rule 86 (compare -> operation EQ operation .)
    IF              reduce using rule 86 (compare -> operation EQ operation .)
    RETURN          reduce using rule 86 (compare -> operation EQ operation .)
    PRINT           reduce using rule 86 (compare -> operation EQ operation .)
    WHILE           reduce using rule 86 (compare -> operation EQ operation .)
    FOR             reduce using rule 86 (compare -> operation EQ operation .)
    ID              reduce using rule 86 (compare -> operation EQ operation .)
    $end            reduce using rule 86 (compare -> operation EQ operation .)
    }               reduce using rule 86 (compare -> operation EQ operation .)
    ELSE            reduce using rule 86 (compare -> operation EQ operation .)
    BREAK           reduce using rule 86 (compare -> operation EQ operation .)
    CONTINUE        reduce using rule 86 (compare -> operation EQ operation .)
    )               reduce using rule 86 (compare -> operation EQ operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 105

    (87) compare -> operation NEQ operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 87 (compare -> operation NEQ operation .)
    {               reduce using rule 87 (compare -> operation NEQ operation .)
    IF              reduce using rule 87 (compare -> operation NEQ operation .)
    RETURN          reduce using rule 87 (compare -> operation NEQ operation .)
    PRINT           reduce using rule 87 (compare -> operation NEQ operation .)
    WHILE           reduce using rule 87 (compare -> operation NEQ operation .)
    FOR             reduce using rule 87 (compare -> operation NEQ operation .)
    ID              reduce using rule 87 (compare -> operation NEQ operation .)
    $end            reduce using rule 87 (compare -> operation NEQ operation .)
    }               reduce using rule 87 (compare -> operation NEQ operation .)
    ELSE            reduce using rule 87 (compare -> operation NEQ operation .)
    BREAK           reduce using rule 87 (compare -> operation NEQ operation .)
    CONTINUE        reduce using rule 87 (compare -> operation NEQ operation .)
    )               reduce using rule 87 (compare -> operation NEQ operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 106

    (88) compare -> operation GEQ operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 88 (compare -> operation GEQ operation .)
    {               reduce using rule 88 (compare -> operation GEQ operation .)
    IF              reduce using rule 88 (compare -> operation GEQ operation .)
    RETURN          reduce using rule 88 (compare -> operation GEQ operation .)
    PRINT           reduce using rule 88 (compare -> operation GEQ operation .)
    WHILE           reduce using rule 88 (compare -> operation GEQ operation .)
    FOR             reduce using rule 88 (compare -> operation GEQ operation .)
    ID              reduce using rule 88 (compare -> operation GEQ operation .)
    $end            reduce using rule 88 (compare -> operation GEQ operation .)
    }               reduce using rule 88 (compare -> operation GEQ operation .)
    ELSE            reduce using rule 88 (compare -> operation GEQ operation .)
    BREAK           reduce using rule 88 (compare -> operation GEQ operation .)
    CONTINUE        reduce using rule 88 (compare -> operation GEQ operation .)
    )               reduce using rule 88 (compare -> operation GEQ operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 107

    (89) compare -> operation LEQ operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 89 (compare -> operation LEQ operation .)
    {               reduce using rule 89 (compare -> operation LEQ operation .)
    IF              reduce using rule 89 (compare -> operation LEQ operation .)
    RETURN          reduce using rule 89 (compare -> operation LEQ operation .)
    PRINT           reduce using rule 89 (compare -> operation LEQ operation .)
    WHILE           reduce using rule 89 (compare -> operation LEQ operation .)
    FOR             reduce using rule 89 (compare -> operation LEQ operation .)
    ID              reduce using rule 89 (compare -> operation LEQ operation .)
    $end            reduce using rule 89 (compare -> operation LEQ operation .)
    }               reduce using rule 89 (compare -> operation LEQ operation .)
    ELSE            reduce using rule 89 (compare -> operation LEQ operation .)
    BREAK           reduce using rule 89 (compare -> operation LEQ operation .)
    CONTINUE        reduce using rule 89 (compare -> operation LEQ operation .)
    )               reduce using rule 89 (compare -> operation LEQ operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 108

    (83) operation -> ( operation ) .

    +               reduce using rule 83 (operation -> ( operation ) .)
    -               reduce using rule 83 (operation -> ( operation ) .)
    DOTADD          reduce using rule 83 (operation -> ( operation ) .)
    DOTSUB          reduce using rule 83 (operation -> ( operation ) .)
    *               reduce using rule 83 (operation -> ( operation ) .)
    /               reduce using rule 83 (operation -> ( operation ) .)
    DOTMUL          reduce using rule 83 (operation -> ( operation ) .)
    DOTDIV          reduce using rule 83 (operation -> ( operation ) .)
    <               reduce using rule 83 (operation -> ( operation ) .)
    >               reduce using rule 83 (operation -> ( operation ) .)
    EQ              reduce using rule 83 (operation -> ( operation ) .)
    NEQ             reduce using rule 83 (operation -> ( operation ) .)
    GEQ             reduce using rule 83 (operation -> ( operation ) .)
    LEQ             reduce using rule 83 (operation -> ( operation ) .)
    ;               reduce using rule 83 (operation -> ( operation ) .)
    {               reduce using rule 83 (operation -> ( operation ) .)
    IF              reduce using rule 83 (operation -> ( operation ) .)
    RETURN          reduce using rule 83 (operation -> ( operation ) .)
    PRINT           reduce using rule 83 (operation -> ( operation ) .)
    WHILE           reduce using rule 83 (operation -> ( operation ) .)
    FOR             reduce using rule 83 (operation -> ( operation ) .)
    ID              reduce using rule 83 (operation -> ( operation ) .)
    $end            reduce using rule 83 (operation -> ( operation ) .)
    }               reduce using rule 83 (operation -> ( operation ) .)
    ELSE            reduce using rule 83 (operation -> ( operation ) .)
    BREAK           reduce using rule 83 (operation -> ( operation ) .)
    CONTINUE        reduce using rule 83 (operation -> ( operation ) .)
    ,               reduce using rule 83 (operation -> ( operation ) .)
    )               reduce using rule 83 (operation -> ( operation ) .)


state 109

    (36) function -> function_n ( number . )

    )               shift and go to state 120


state 110

    (18) print_b -> print_b , operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTADD operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ,               reduce using rule 18 (print_b -> print_b , operation .)
    ;               reduce using rule 18 (print_b -> print_b , operation .)
    {               reduce using rule 18 (print_b -> print_b , operation .)
    IF              reduce using rule 18 (print_b -> print_b , operation .)
    RETURN          reduce using rule 18 (print_b -> print_b , operation .)
    PRINT           reduce using rule 18 (print_b -> print_b , operation .)
    WHILE           reduce using rule 18 (print_b -> print_b , operation .)
    FOR             reduce using rule 18 (print_b -> print_b , operation .)
    ID              reduce using rule 18 (print_b -> print_b , operation .)
    $end            reduce using rule 18 (print_b -> print_b , operation .)
    }               reduce using rule 18 (print_b -> print_b , operation .)
    ELSE            reduce using rule 18 (print_b -> print_b , operation .)
    BREAK           reduce using rule 18 (print_b -> print_b , operation .)
    CONTINUE        reduce using rule 18 (print_b -> print_b , operation .)
    +               shift and go to state 64
    -               shift and go to state 65
    DOTADD          shift and go to state 66
    DOTSUB          shift and go to state 67
    *               shift and go to state 68
    /               shift and go to state 69
    DOTMUL          shift and go to state 70
    DOTDIV          shift and go to state 71


state 111

    (43) while -> WHILE ( condition ) . loop_b
    (45) loop_b -> . loop_expr
    (46) loop_b -> . loop_expr ;
    (47) loop_b -> . { m_loop_expr }
    (48) loop_expr -> . base_expr
    (49) loop_expr -> . loop_st
    (50) loop_expr -> . if_loop_st
    (51) loop_expr -> . BREAK
    (52) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (41) loop_st -> . while
    (42) loop_st -> . for
    (58) if_loop_st -> . IF ( condition ) loop_b else_loop_st
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    loop_b                         shift and go to state 121
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop_st                        shift and go to state 125
    if_loop_st                     shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 112

    (44) for -> FOR ID = int_variable . : int_variable loop_b

    :               shift and go to state 130


state 113

    (33) range -> ID [ int_variable , . int_variable ]
    (34) int_variable -> . INTNUM
    (35) int_variable -> . ID

    INTNUM          shift and go to state 88
    ID              shift and go to state 86

    int_variable                   shift and go to state 131

state 114

    (55) if_st -> IF ( condition ) expression . else_st
    (56) else_st -> . ELSE expression
    (57) else_st -> . eps
    (61) eps -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 133
    {               reduce using rule 61 (eps -> .)
    IF              reduce using rule 61 (eps -> .)
    RETURN          reduce using rule 61 (eps -> .)
    PRINT           reduce using rule 61 (eps -> .)
    WHILE           reduce using rule 61 (eps -> .)
    FOR             reduce using rule 61 (eps -> .)
    ID              reduce using rule 61 (eps -> .)
    $end            reduce using rule 61 (eps -> .)
    }               reduce using rule 61 (eps -> .)

  ! ELSE            [ reduce using rule 61 (eps -> .) ]

    else_st                        shift and go to state 132
    eps                            shift and go to state 134

state 115

    (22) array -> [ array_b . ]
    (24) array_b -> array_b . , number

    ]               shift and go to state 135
    ,               shift and go to state 136


state 116

    (23) array_b -> number .

    ]               reduce using rule 23 (array_b -> number .)
    ,               reduce using rule 23 (array_b -> number .)


state 117

    (25) array_b -> eps .

    ]               reduce using rule 25 (array_b -> eps .)
    ,               reduce using rule 25 (array_b -> eps .)


state 118

    (26) matrix -> [ matrix_b ] .

    ;               reduce using rule 26 (matrix -> [ matrix_b ] .)
    {               reduce using rule 26 (matrix -> [ matrix_b ] .)
    IF              reduce using rule 26 (matrix -> [ matrix_b ] .)
    RETURN          reduce using rule 26 (matrix -> [ matrix_b ] .)
    PRINT           reduce using rule 26 (matrix -> [ matrix_b ] .)
    WHILE           reduce using rule 26 (matrix -> [ matrix_b ] .)
    FOR             reduce using rule 26 (matrix -> [ matrix_b ] .)
    ID              reduce using rule 26 (matrix -> [ matrix_b ] .)
    $end            reduce using rule 26 (matrix -> [ matrix_b ] .)
    }               reduce using rule 26 (matrix -> [ matrix_b ] .)
    ELSE            reduce using rule 26 (matrix -> [ matrix_b ] .)
    BREAK           reduce using rule 26 (matrix -> [ matrix_b ] .)
    CONTINUE        reduce using rule 26 (matrix -> [ matrix_b ] .)


state 119

    (28) matrix_b -> matrix_b , . array
    (22) array -> . [ array_b ]

    [               shift and go to state 90

    array                          shift and go to state 137

state 120

    (36) function -> function_n ( number ) .

    +               reduce using rule 36 (function -> function_n ( number ) .)
    -               reduce using rule 36 (function -> function_n ( number ) .)
    DOTADD          reduce using rule 36 (function -> function_n ( number ) .)
    DOTSUB          reduce using rule 36 (function -> function_n ( number ) .)
    *               reduce using rule 36 (function -> function_n ( number ) .)
    /               reduce using rule 36 (function -> function_n ( number ) .)
    DOTMUL          reduce using rule 36 (function -> function_n ( number ) .)
    DOTDIV          reduce using rule 36 (function -> function_n ( number ) .)
    <               reduce using rule 36 (function -> function_n ( number ) .)
    >               reduce using rule 36 (function -> function_n ( number ) .)
    EQ              reduce using rule 36 (function -> function_n ( number ) .)
    NEQ             reduce using rule 36 (function -> function_n ( number ) .)
    GEQ             reduce using rule 36 (function -> function_n ( number ) .)
    LEQ             reduce using rule 36 (function -> function_n ( number ) .)
    ;               reduce using rule 36 (function -> function_n ( number ) .)
    {               reduce using rule 36 (function -> function_n ( number ) .)
    IF              reduce using rule 36 (function -> function_n ( number ) .)
    RETURN          reduce using rule 36 (function -> function_n ( number ) .)
    PRINT           reduce using rule 36 (function -> function_n ( number ) .)
    WHILE           reduce using rule 36 (function -> function_n ( number ) .)
    FOR             reduce using rule 36 (function -> function_n ( number ) .)
    ID              reduce using rule 36 (function -> function_n ( number ) .)
    $end            reduce using rule 36 (function -> function_n ( number ) .)
    }               reduce using rule 36 (function -> function_n ( number ) .)
    ELSE            reduce using rule 36 (function -> function_n ( number ) .)
    BREAK           reduce using rule 36 (function -> function_n ( number ) .)
    CONTINUE        reduce using rule 36 (function -> function_n ( number ) .)
    ,               reduce using rule 36 (function -> function_n ( number ) .)
    )               reduce using rule 36 (function -> function_n ( number ) .)


state 121

    (43) while -> WHILE ( condition ) loop_b .

    {               reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    IF              reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    RETURN          reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    PRINT           reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    WHILE           reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    FOR             reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    ID              reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    $end            reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    }               reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    ELSE            reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    ;               reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    BREAK           reduce using rule 43 (while -> WHILE ( condition ) loop_b .)
    CONTINUE        reduce using rule 43 (while -> WHILE ( condition ) loop_b .)


state 122

    (45) loop_b -> loop_expr .
    (46) loop_b -> loop_expr . ;

  ! shift/reduce conflict for ; resolved as shift
    {               reduce using rule 45 (loop_b -> loop_expr .)
    IF              reduce using rule 45 (loop_b -> loop_expr .)
    RETURN          reduce using rule 45 (loop_b -> loop_expr .)
    PRINT           reduce using rule 45 (loop_b -> loop_expr .)
    WHILE           reduce using rule 45 (loop_b -> loop_expr .)
    FOR             reduce using rule 45 (loop_b -> loop_expr .)
    ID              reduce using rule 45 (loop_b -> loop_expr .)
    $end            reduce using rule 45 (loop_b -> loop_expr .)
    }               reduce using rule 45 (loop_b -> loop_expr .)
    ELSE            reduce using rule 45 (loop_b -> loop_expr .)
    BREAK           reduce using rule 45 (loop_b -> loop_expr .)
    CONTINUE        reduce using rule 45 (loop_b -> loop_expr .)
    ;               shift and go to state 138

  ! ;               [ reduce using rule 45 (loop_b -> loop_expr .) ]


state 123

    (47) loop_b -> { . m_loop_expr }
    (53) m_loop_expr -> . m_loop_expr loop_b
    (54) m_loop_expr -> . loop_b
    (45) loop_b -> . loop_expr
    (46) loop_b -> . loop_expr ;
    (47) loop_b -> . { m_loop_expr }
    (48) loop_expr -> . base_expr
    (49) loop_expr -> . loop_st
    (50) loop_expr -> . if_loop_st
    (51) loop_expr -> . BREAK
    (52) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (41) loop_st -> . while
    (42) loop_st -> . for
    (58) if_loop_st -> . IF ( condition ) loop_b else_loop_st
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    m_loop_expr                    shift and go to state 139
    loop_b                         shift and go to state 140
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop_st                        shift and go to state 125
    if_loop_st                     shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 124

    (48) loop_expr -> base_expr .

    ;               reduce using rule 48 (loop_expr -> base_expr .)
    {               reduce using rule 48 (loop_expr -> base_expr .)
    IF              reduce using rule 48 (loop_expr -> base_expr .)
    RETURN          reduce using rule 48 (loop_expr -> base_expr .)
    PRINT           reduce using rule 48 (loop_expr -> base_expr .)
    WHILE           reduce using rule 48 (loop_expr -> base_expr .)
    FOR             reduce using rule 48 (loop_expr -> base_expr .)
    ID              reduce using rule 48 (loop_expr -> base_expr .)
    $end            reduce using rule 48 (loop_expr -> base_expr .)
    }               reduce using rule 48 (loop_expr -> base_expr .)
    ELSE            reduce using rule 48 (loop_expr -> base_expr .)
    BREAK           reduce using rule 48 (loop_expr -> base_expr .)
    CONTINUE        reduce using rule 48 (loop_expr -> base_expr .)


state 125

    (49) loop_expr -> loop_st .

    ;               reduce using rule 49 (loop_expr -> loop_st .)
    {               reduce using rule 49 (loop_expr -> loop_st .)
    IF              reduce using rule 49 (loop_expr -> loop_st .)
    RETURN          reduce using rule 49 (loop_expr -> loop_st .)
    PRINT           reduce using rule 49 (loop_expr -> loop_st .)
    WHILE           reduce using rule 49 (loop_expr -> loop_st .)
    FOR             reduce using rule 49 (loop_expr -> loop_st .)
    ID              reduce using rule 49 (loop_expr -> loop_st .)
    $end            reduce using rule 49 (loop_expr -> loop_st .)
    }               reduce using rule 49 (loop_expr -> loop_st .)
    ELSE            reduce using rule 49 (loop_expr -> loop_st .)
    BREAK           reduce using rule 49 (loop_expr -> loop_st .)
    CONTINUE        reduce using rule 49 (loop_expr -> loop_st .)


state 126

    (50) loop_expr -> if_loop_st .

    ;               reduce using rule 50 (loop_expr -> if_loop_st .)
    {               reduce using rule 50 (loop_expr -> if_loop_st .)
    IF              reduce using rule 50 (loop_expr -> if_loop_st .)
    RETURN          reduce using rule 50 (loop_expr -> if_loop_st .)
    PRINT           reduce using rule 50 (loop_expr -> if_loop_st .)
    WHILE           reduce using rule 50 (loop_expr -> if_loop_st .)
    FOR             reduce using rule 50 (loop_expr -> if_loop_st .)
    ID              reduce using rule 50 (loop_expr -> if_loop_st .)
    $end            reduce using rule 50 (loop_expr -> if_loop_st .)
    }               reduce using rule 50 (loop_expr -> if_loop_st .)
    ELSE            reduce using rule 50 (loop_expr -> if_loop_st .)
    BREAK           reduce using rule 50 (loop_expr -> if_loop_st .)
    CONTINUE        reduce using rule 50 (loop_expr -> if_loop_st .)


state 127

    (51) loop_expr -> BREAK .

    ;               reduce using rule 51 (loop_expr -> BREAK .)
    {               reduce using rule 51 (loop_expr -> BREAK .)
    IF              reduce using rule 51 (loop_expr -> BREAK .)
    RETURN          reduce using rule 51 (loop_expr -> BREAK .)
    PRINT           reduce using rule 51 (loop_expr -> BREAK .)
    WHILE           reduce using rule 51 (loop_expr -> BREAK .)
    FOR             reduce using rule 51 (loop_expr -> BREAK .)
    ID              reduce using rule 51 (loop_expr -> BREAK .)
    $end            reduce using rule 51 (loop_expr -> BREAK .)
    }               reduce using rule 51 (loop_expr -> BREAK .)
    ELSE            reduce using rule 51 (loop_expr -> BREAK .)
    BREAK           reduce using rule 51 (loop_expr -> BREAK .)
    CONTINUE        reduce using rule 51 (loop_expr -> BREAK .)


state 128

    (52) loop_expr -> CONTINUE .

    ;               reduce using rule 52 (loop_expr -> CONTINUE .)
    {               reduce using rule 52 (loop_expr -> CONTINUE .)
    IF              reduce using rule 52 (loop_expr -> CONTINUE .)
    RETURN          reduce using rule 52 (loop_expr -> CONTINUE .)
    PRINT           reduce using rule 52 (loop_expr -> CONTINUE .)
    WHILE           reduce using rule 52 (loop_expr -> CONTINUE .)
    FOR             reduce using rule 52 (loop_expr -> CONTINUE .)
    ID              reduce using rule 52 (loop_expr -> CONTINUE .)
    $end            reduce using rule 52 (loop_expr -> CONTINUE .)
    }               reduce using rule 52 (loop_expr -> CONTINUE .)
    ELSE            reduce using rule 52 (loop_expr -> CONTINUE .)
    BREAK           reduce using rule 52 (loop_expr -> CONTINUE .)
    CONTINUE        reduce using rule 52 (loop_expr -> CONTINUE .)


state 129

    (58) if_loop_st -> IF . ( condition ) loop_b else_loop_st

    (               shift and go to state 141


state 130

    (44) for -> FOR ID = int_variable : . int_variable loop_b
    (34) int_variable -> . INTNUM
    (35) int_variable -> . ID

    INTNUM          shift and go to state 88
    ID              shift and go to state 86

    int_variable                   shift and go to state 142

state 131

    (33) range -> ID [ int_variable , int_variable . ]

    ]               shift and go to state 143


state 132

    (55) if_st -> IF ( condition ) expression else_st .

    {               reduce using rule 55 (if_st -> IF ( condition ) expression else_st .)
    IF              reduce using rule 55 (if_st -> IF ( condition ) expression else_st .)
    RETURN          reduce using rule 55 (if_st -> IF ( condition ) expression else_st .)
    PRINT           reduce using rule 55 (if_st -> IF ( condition ) expression else_st .)
    WHILE           reduce using rule 55 (if_st -> IF ( condition ) expression else_st .)
    FOR             reduce using rule 55 (if_st -> IF ( condition ) expression else_st .)
    ID              reduce using rule 55 (if_st -> IF ( condition ) expression else_st .)
    $end            reduce using rule 55 (if_st -> IF ( condition ) expression else_st .)
    }               reduce using rule 55 (if_st -> IF ( condition ) expression else_st .)
    ELSE            reduce using rule 55 (if_st -> IF ( condition ) expression else_st .)


state 133

    (56) else_st -> ELSE . expression
    (3) expression -> . c_block
    (4) expression -> . base_expr
    (5) expression -> . base_expr ;
    (6) expression -> . if_st
    (7) expression -> . loop_st
    (14) c_block -> . { m_expr }
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (55) if_st -> . IF ( condition ) expression else_st
    (41) loop_st -> . while
    (42) loop_st -> . for
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    {               shift and go to state 7
    IF              shift and go to state 11
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    expression                     shift and go to state 144
    c_block                        shift and go to state 3
    base_expr                      shift and go to state 4
    if_st                          shift and go to state 5
    loop_st                        shift and go to state 6
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 134

    (57) else_st -> eps .

    ELSE            reduce using rule 57 (else_st -> eps .)
    {               reduce using rule 57 (else_st -> eps .)
    IF              reduce using rule 57 (else_st -> eps .)
    RETURN          reduce using rule 57 (else_st -> eps .)
    PRINT           reduce using rule 57 (else_st -> eps .)
    WHILE           reduce using rule 57 (else_st -> eps .)
    FOR             reduce using rule 57 (else_st -> eps .)
    ID              reduce using rule 57 (else_st -> eps .)
    $end            reduce using rule 57 (else_st -> eps .)
    }               reduce using rule 57 (else_st -> eps .)


state 135

    (22) array -> [ array_b ] .

    ]               reduce using rule 22 (array -> [ array_b ] .)
    ,               reduce using rule 22 (array -> [ array_b ] .)


state 136

    (24) array_b -> array_b , . number
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID

    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 79

    number                         shift and go to state 145

state 137

    (28) matrix_b -> matrix_b , array .

    ]               reduce using rule 28 (matrix_b -> matrix_b , array .)
    ,               reduce using rule 28 (matrix_b -> matrix_b , array .)


state 138

    (46) loop_b -> loop_expr ; .

    ;               reduce using rule 46 (loop_b -> loop_expr ; .)
    {               reduce using rule 46 (loop_b -> loop_expr ; .)
    IF              reduce using rule 46 (loop_b -> loop_expr ; .)
    RETURN          reduce using rule 46 (loop_b -> loop_expr ; .)
    PRINT           reduce using rule 46 (loop_b -> loop_expr ; .)
    WHILE           reduce using rule 46 (loop_b -> loop_expr ; .)
    FOR             reduce using rule 46 (loop_b -> loop_expr ; .)
    ID              reduce using rule 46 (loop_b -> loop_expr ; .)
    $end            reduce using rule 46 (loop_b -> loop_expr ; .)
    }               reduce using rule 46 (loop_b -> loop_expr ; .)
    ELSE            reduce using rule 46 (loop_b -> loop_expr ; .)
    BREAK           reduce using rule 46 (loop_b -> loop_expr ; .)
    CONTINUE        reduce using rule 46 (loop_b -> loop_expr ; .)


state 139

    (47) loop_b -> { m_loop_expr . }
    (53) m_loop_expr -> m_loop_expr . loop_b
    (45) loop_b -> . loop_expr
    (46) loop_b -> . loop_expr ;
    (47) loop_b -> . { m_loop_expr }
    (48) loop_expr -> . base_expr
    (49) loop_expr -> . loop_st
    (50) loop_expr -> . if_loop_st
    (51) loop_expr -> . BREAK
    (52) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (41) loop_st -> . while
    (42) loop_st -> . for
    (58) if_loop_st -> . IF ( condition ) loop_b else_loop_st
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    }               shift and go to state 146
    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    loop_b                         shift and go to state 147
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop_st                        shift and go to state 125
    if_loop_st                     shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 140

    (54) m_loop_expr -> loop_b .

    }               reduce using rule 54 (m_loop_expr -> loop_b .)
    {               reduce using rule 54 (m_loop_expr -> loop_b .)
    BREAK           reduce using rule 54 (m_loop_expr -> loop_b .)
    CONTINUE        reduce using rule 54 (m_loop_expr -> loop_b .)
    IF              reduce using rule 54 (m_loop_expr -> loop_b .)
    RETURN          reduce using rule 54 (m_loop_expr -> loop_b .)
    PRINT           reduce using rule 54 (m_loop_expr -> loop_b .)
    WHILE           reduce using rule 54 (m_loop_expr -> loop_b .)
    FOR             reduce using rule 54 (m_loop_expr -> loop_b .)
    ID              reduce using rule 54 (m_loop_expr -> loop_b .)


state 141

    (58) if_loop_st -> IF ( . condition ) loop_b else_loop_st
    (40) condition -> . compare
    (84) compare -> . operation < operation
    (85) compare -> . operation > operation
    (86) compare -> . operation EQ operation
    (87) compare -> . operation NEQ operation
    (88) compare -> . operation GEQ operation
    (89) compare -> . operation LEQ operation
    (11) operation -> . number
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTADD operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (83) operation -> . ( operation )
    (30) number -> . INTNUM
    (31) number -> . FLOATNUM
    (32) number -> . ID
    (71) unary_operation -> . negation
    (72) unary_operation -> . transpose
    (36) function -> . function_n ( number )
    (73) negation -> . - number
    (74) transpose -> . ID '
    (37) function_n -> . ONES
    (38) function_n -> . EYE
    (39) function_n -> . ZEROS

    (               shift and go to state 37
    INTNUM          shift and go to state 38
    FLOATNUM        shift and go to state 39
    ID              shift and go to state 40
    -               shift and go to state 36
    ONES            shift and go to state 44
    EYE             shift and go to state 45
    ZEROS           shift and go to state 46

    condition                      shift and go to state 148
    compare                        shift and go to state 32
    operation                      shift and go to state 55
    number                         shift and go to state 33
    unary_operation                shift and go to state 34
    function                       shift and go to state 35
    negation                       shift and go to state 41
    transpose                      shift and go to state 42
    function_n                     shift and go to state 43

state 142

    (44) for -> FOR ID = int_variable : int_variable . loop_b
    (45) loop_b -> . loop_expr
    (46) loop_b -> . loop_expr ;
    (47) loop_b -> . { m_loop_expr }
    (48) loop_expr -> . base_expr
    (49) loop_expr -> . loop_st
    (50) loop_expr -> . if_loop_st
    (51) loop_expr -> . BREAK
    (52) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (41) loop_st -> . while
    (42) loop_st -> . for
    (58) if_loop_st -> . IF ( condition ) loop_b else_loop_st
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    loop_b                         shift and go to state 149
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop_st                        shift and go to state 125
    if_loop_st                     shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 143

    (33) range -> ID [ int_variable , int_variable ] .

    =               reduce using rule 33 (range -> ID [ int_variable , int_variable ] .)
    ASSIGNADD       reduce using rule 33 (range -> ID [ int_variable , int_variable ] .)
    ASSIGNSUB       reduce using rule 33 (range -> ID [ int_variable , int_variable ] .)
    ASSIGNMUL       reduce using rule 33 (range -> ID [ int_variable , int_variable ] .)
    ASSIGNDIV       reduce using rule 33 (range -> ID [ int_variable , int_variable ] .)


state 144

    (56) else_st -> ELSE expression .

    ELSE            reduce using rule 56 (else_st -> ELSE expression .)
    {               reduce using rule 56 (else_st -> ELSE expression .)
    IF              reduce using rule 56 (else_st -> ELSE expression .)
    RETURN          reduce using rule 56 (else_st -> ELSE expression .)
    PRINT           reduce using rule 56 (else_st -> ELSE expression .)
    WHILE           reduce using rule 56 (else_st -> ELSE expression .)
    FOR             reduce using rule 56 (else_st -> ELSE expression .)
    ID              reduce using rule 56 (else_st -> ELSE expression .)
    $end            reduce using rule 56 (else_st -> ELSE expression .)
    }               reduce using rule 56 (else_st -> ELSE expression .)


state 145

    (24) array_b -> array_b , number .

    ]               reduce using rule 24 (array_b -> array_b , number .)
    ,               reduce using rule 24 (array_b -> array_b , number .)


state 146

    (47) loop_b -> { m_loop_expr } .

    ;               reduce using rule 47 (loop_b -> { m_loop_expr } .)
    {               reduce using rule 47 (loop_b -> { m_loop_expr } .)
    IF              reduce using rule 47 (loop_b -> { m_loop_expr } .)
    RETURN          reduce using rule 47 (loop_b -> { m_loop_expr } .)
    PRINT           reduce using rule 47 (loop_b -> { m_loop_expr } .)
    WHILE           reduce using rule 47 (loop_b -> { m_loop_expr } .)
    FOR             reduce using rule 47 (loop_b -> { m_loop_expr } .)
    ID              reduce using rule 47 (loop_b -> { m_loop_expr } .)
    $end            reduce using rule 47 (loop_b -> { m_loop_expr } .)
    }               reduce using rule 47 (loop_b -> { m_loop_expr } .)
    ELSE            reduce using rule 47 (loop_b -> { m_loop_expr } .)
    BREAK           reduce using rule 47 (loop_b -> { m_loop_expr } .)
    CONTINUE        reduce using rule 47 (loop_b -> { m_loop_expr } .)


state 147

    (53) m_loop_expr -> m_loop_expr loop_b .

    }               reduce using rule 53 (m_loop_expr -> m_loop_expr loop_b .)
    {               reduce using rule 53 (m_loop_expr -> m_loop_expr loop_b .)
    BREAK           reduce using rule 53 (m_loop_expr -> m_loop_expr loop_b .)
    CONTINUE        reduce using rule 53 (m_loop_expr -> m_loop_expr loop_b .)
    IF              reduce using rule 53 (m_loop_expr -> m_loop_expr loop_b .)
    RETURN          reduce using rule 53 (m_loop_expr -> m_loop_expr loop_b .)
    PRINT           reduce using rule 53 (m_loop_expr -> m_loop_expr loop_b .)
    WHILE           reduce using rule 53 (m_loop_expr -> m_loop_expr loop_b .)
    FOR             reduce using rule 53 (m_loop_expr -> m_loop_expr loop_b .)
    ID              reduce using rule 53 (m_loop_expr -> m_loop_expr loop_b .)


state 148

    (58) if_loop_st -> IF ( condition . ) loop_b else_loop_st

    )               shift and go to state 150


state 149

    (44) for -> FOR ID = int_variable : int_variable loop_b .

    {               reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    IF              reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    RETURN          reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    PRINT           reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    WHILE           reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    FOR             reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    ID              reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    $end            reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    }               reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    ELSE            reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    ;               reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    BREAK           reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)
    CONTINUE        reduce using rule 44 (for -> FOR ID = int_variable : int_variable loop_b .)


state 150

    (58) if_loop_st -> IF ( condition ) . loop_b else_loop_st
    (45) loop_b -> . loop_expr
    (46) loop_b -> . loop_expr ;
    (47) loop_b -> . { m_loop_expr }
    (48) loop_expr -> . base_expr
    (49) loop_expr -> . loop_st
    (50) loop_expr -> . if_loop_st
    (51) loop_expr -> . BREAK
    (52) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (41) loop_st -> . while
    (42) loop_st -> . for
    (58) if_loop_st -> . IF ( condition ) loop_b else_loop_st
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    loop_b                         shift and go to state 151
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop_st                        shift and go to state 125
    if_loop_st                     shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 151

    (58) if_loop_st -> IF ( condition ) loop_b . else_loop_st
    (59) else_loop_st -> . ELSE loop_b
    (60) else_loop_st -> . eps
    (61) eps -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 153
    ;               reduce using rule 61 (eps -> .)
    {               reduce using rule 61 (eps -> .)
    IF              reduce using rule 61 (eps -> .)
    RETURN          reduce using rule 61 (eps -> .)
    PRINT           reduce using rule 61 (eps -> .)
    WHILE           reduce using rule 61 (eps -> .)
    FOR             reduce using rule 61 (eps -> .)
    ID              reduce using rule 61 (eps -> .)
    $end            reduce using rule 61 (eps -> .)
    }               reduce using rule 61 (eps -> .)
    BREAK           reduce using rule 61 (eps -> .)
    CONTINUE        reduce using rule 61 (eps -> .)

  ! ELSE            [ reduce using rule 61 (eps -> .) ]

    else_loop_st                   shift and go to state 152
    eps                            shift and go to state 154

state 152

    (58) if_loop_st -> IF ( condition ) loop_b else_loop_st .

    ;               reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    {               reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    IF              reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    RETURN          reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    PRINT           reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    WHILE           reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    FOR             reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    ID              reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    $end            reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    }               reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    ELSE            reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    BREAK           reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)
    CONTINUE        reduce using rule 58 (if_loop_st -> IF ( condition ) loop_b else_loop_st .)


state 153

    (59) else_loop_st -> ELSE . loop_b
    (45) loop_b -> . loop_expr
    (46) loop_b -> . loop_expr ;
    (47) loop_b -> . { m_loop_expr }
    (48) loop_expr -> . base_expr
    (49) loop_expr -> . loop_st
    (50) loop_expr -> . if_loop_st
    (51) loop_expr -> . BREAK
    (52) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (41) loop_st -> . while
    (42) loop_st -> . for
    (58) if_loop_st -> . IF ( condition ) loop_b else_loop_st
    (64) assignment -> . assign_expr = matrix
    (65) assignment -> . assign_expr = STRING
    (66) assignment -> . assign_expr = operation
    (67) assignment -> . assign_expr ASSIGNADD operation
    (68) assignment -> . assign_expr ASSIGNSUB operation
    (69) assignment -> . assign_expr ASSIGNMUL operation
    (70) assignment -> . assign_expr ASSIGNDIV operation
    (19) return -> . RETURN condition
    (20) return -> . RETURN operation
    (21) return -> . RETURN
    (15) print -> . PRINT print_b
    (43) while -> . WHILE ( condition ) loop_b
    (44) for -> . FOR ID = int_variable : int_variable loop_b
    (62) assign_expr -> . ID
    (63) assign_expr -> . range
    (33) range -> . ID [ int_variable , int_variable ]

    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    WHILE           shift and go to state 17
    FOR             shift and go to state 18
    ID              shift and go to state 19

    loop_b                         shift and go to state 155
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop_st                        shift and go to state 125
    if_loop_st                     shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assign_expr                    shift and go to state 14
    range                          shift and go to state 20

state 154

    (60) else_loop_st -> eps .

    ;               reduce using rule 60 (else_loop_st -> eps .)
    {               reduce using rule 60 (else_loop_st -> eps .)
    IF              reduce using rule 60 (else_loop_st -> eps .)
    RETURN          reduce using rule 60 (else_loop_st -> eps .)
    PRINT           reduce using rule 60 (else_loop_st -> eps .)
    WHILE           reduce using rule 60 (else_loop_st -> eps .)
    FOR             reduce using rule 60 (else_loop_st -> eps .)
    ID              reduce using rule 60 (else_loop_st -> eps .)
    $end            reduce using rule 60 (else_loop_st -> eps .)
    }               reduce using rule 60 (else_loop_st -> eps .)
    ELSE            reduce using rule 60 (else_loop_st -> eps .)
    BREAK           reduce using rule 60 (else_loop_st -> eps .)
    CONTINUE        reduce using rule 60 (else_loop_st -> eps .)


state 155

    (59) else_loop_st -> ELSE loop_b .

    ;               reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    {               reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    IF              reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    RETURN          reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    PRINT           reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    WHILE           reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    FOR             reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    ID              reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    $end            reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    }               reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    ELSE            reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    BREAK           reduce using rule 59 (else_loop_st -> ELSE loop_b .)
    CONTINUE        reduce using rule 59 (else_loop_st -> ELSE loop_b .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 15 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 114 resolved as shift
WARNING: shift/reduce conflict for ; in state 122 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 151 resolved as shift
